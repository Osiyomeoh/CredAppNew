"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSolidity = void 0;
const abi_utils_1 = require("@truffle/abi-utils");
const package_json_1 = require("../package.json");
const visitor_1 = require("./visitor");
const version_features_1 = require("./version-features");
const defaults = __importStar(require("./defaults"));
const declarations_1 = require("./declarations");
const abi_features_1 = require("./abi-features");
let prettier;
try {
    prettier = require("prettier");
}
catch (_a) {
    // no-op
}
const generateSolidity = ({ abi, name = defaults.name, solidityVersion = defaults.solidityVersion, license = defaults.license, outputAttribution = defaults.outputAttribution, outputSource = defaults.outputSource, prettifyOutput = prettier && defaults.prettifyOutput, }) => {
    if (!prettier && prettifyOutput) {
        throw new Error("Could not require() prettier");
    }
    const versionFeatures = (0, version_features_1.forRange)(solidityVersion);
    const abiFeatures = (0, abi_features_1.collectAbiFeatures)(abi);
    const declarations = (0, declarations_1.collectDeclarations)(abi);
    const generated = (0, visitor_1.dispatch)({
        node: abi,
        visitor: new SolidityGenerator({
            name,
            solidityVersion,
            license,
            outputAttribution,
            outputSource,
            versionFeatures,
            abiFeatures,
            declarations,
        }),
    });
    if (!prettifyOutput) {
        return generated;
    }
    try {
        return prettier.format(generated, {
            plugins: ["prettier-plugin-solidity"],
            // @ts-ignore
            parser: "solidity-parse",
        });
    }
    catch (error) {
        return generated;
    }
};
exports.generateSolidity = generateSolidity;
const shimGlobalInterfaceName = "__Structs";
class SolidityGenerator {
    constructor({ name, license, outputAttribution, outputSource, solidityVersion, versionFeatures, abiFeatures, declarations, }) {
        this.name = name;
        this.license = license;
        this.solidityVersion = solidityVersion;
        this.versionFeatures = versionFeatures;
        this.abiFeatures = abiFeatures;
        this.declarations = declarations;
        this.outputAttribution = outputAttribution;
        this.outputSource = outputSource;
        this.identifiers = {};
        let index = 0;
        for (const [container, signatures] of Object.entries(declarations.containerSignatures)) {
            for (const signature of signatures) {
                const { identifier = `S_${index++}` } = declarations.signatureDeclarations[signature];
                if (container === "" && this.versionFeatures["global-structs"] !== true) {
                    this.identifiers[signature] = {
                        container: shimGlobalInterfaceName,
                        identifier
                    };
                }
                else if (container === "") {
                    this.identifiers[signature] = { identifier };
                }
                else {
                    this.identifiers[signature] = {
                        container,
                        identifier
                    };
                }
            }
        }
    }
    visitAbi({ node: abi }) {
        return [
            this.generateHeader(),
            this.generateInterface(abi),
            this.generateDeclarations(),
            this.generateAutogeneratedNotice(abi),
        ].join("\n\n");
    }
    visitFunctionEntry({ node: entry, context }) {
        const { name, inputs, stateMutability } = entry;
        return [
            `function ${name}(`,
            entry.inputs.map((node) => (0, visitor_1.dispatch)({
                node,
                visitor: this,
                context: Object.assign(Object.assign({}, context), { parameterModifiers: (parameter) => parameter.type.startsWith("tuple") ||
                        parameter.type.includes("[") ||
                        parameter.type === "bytes" ||
                        parameter.type === "string"
                        ? [this.generateArrayParameterLocation(parameter)]
                        : [] }),
            })),
            `) external`,
            this.generateStateMutability(entry),
            entry.outputs && entry.outputs.length > 0
                ? [
                    `returns (`,
                    entry.outputs
                        .map((node) => (0, visitor_1.dispatch)({
                        node,
                        visitor: this,
                        context: {
                            parameterModifiers: (parameter) => parameter.type.startsWith("tuple") ||
                                parameter.type.includes("[") ||
                                parameter.type === "bytes" ||
                                parameter.type === "string"
                                ? ["memory"]
                                : [],
                        },
                    }))
                        .join(", "),
                    `)`,
                ].join("")
                : ``,
            `;`,
        ].join(" ");
    }
    visitConstructorEntry({ node: entry }) {
        // interfaces don't have constructors
        return "";
    }
    visitFallbackEntry({ node: entry }) {
        const servesAsReceive = this.abiFeatures["defines-receive"] &&
            this.versionFeatures["receive-keyword"] !== true;
        const { stateMutability } = entry;
        return `${this.generateFallbackName()} () external ${stateMutability === "payable" || servesAsReceive ? "payable" : ""};`;
    }
    visitReceiveEntry() {
        // if version has receive, emit as normal
        if (this.versionFeatures["receive-keyword"] === true) {
            return `receive () external payable;`;
        }
        // if this ABI defines a fallback separately, emit nothing, since
        // visitFallbackEntry will cover it
        if (this.abiFeatures["defines-fallback"]) {
            return "";
        }
        // otherwise, explicitly invoke visitFallbackEntry
        return this.visitFallbackEntry({
            node: { type: "fallback", stateMutability: "payable" },
        });
    }
    visitEventEntry({ node: entry, context }) {
        const { name, inputs, anonymous } = entry;
        return [
            `event ${name}(`,
            inputs.map((node) => (0, visitor_1.dispatch)({
                node,
                visitor: this,
                context: Object.assign(Object.assign({}, context), { parameterModifiers: (parameter) => 
                    // TODO fix this
                    parameter.indexed ? ["indexed"] : [] }),
            })),
            `)`,
            `${anonymous ? "anonymous" : ""};`,
        ].join(" ");
    }
    visitErrorEntry({ node: entry, context }) {
        if (this.versionFeatures["custom-errors"] !== true) {
            throw new Error("ABI defines custom errors; use Solidity v0.8.4 or higher");
        }
        const { name, inputs } = entry;
        return [
            `error ${name}(`,
            inputs.map((node) => (0, visitor_1.dispatch)({
                node,
                visitor: this,
                context: Object.assign(Object.assign({}, context), { parameterModifiers: (parameter) => [] }),
            })),
            `);`,
        ].join(" ");
    }
    visitParameter({ node: parameter, context }) {
        const type = this.generateType(parameter, context);
        // @ts-ignore
        const { parameterModifiers } = context;
        return [type, ...parameterModifiers(parameter), parameter.name].join(" ");
    }
    generateHeader() {
        const includeExperimentalPragma = this.abiFeatures["needs-abiencoder-v2"] &&
            this.versionFeatures["abiencoder-v2"] !== "default";
        const attribution = !this.outputAttribution
            ? []
            : !this.outputSource
                ? [`// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v${package_json_1.version}. !!`]
                : [`// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v${package_json_1.version}. SEE SOURCE BELOW. !!`];
        return [
            `// SPDX-License-Identifier: ${this.license}`,
            ...attribution,
            `pragma solidity ${this.solidityVersion};`,
            ...(includeExperimentalPragma
                ? [`pragma experimental ABIEncoderV2;`]
                : [])
        ].join("\n");
    }
    generateAutogeneratedNotice(abi) {
        if (!this.outputSource) {
            return "";
        }
        return [
            ``,
            `// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:`,
            `/*`,
            JSON.stringify(abi),
            `*/`,
        ].join("\n");
    }
    generateDeclarations() {
        if (this.versionFeatures["structs-in-interfaces"] !== true &&
            Object.keys(this.declarations.signatureDeclarations).length > 0) {
            throw new Error("abi-to-sol does not support custom struct types for this Solidity version");
        }
        const externalContainers = Object.keys(this.declarations.containerSignatures)
            .filter(container => container !== "" && container !== this.name);
        const externalDeclarations = externalContainers
            .map(container => [
            `interface ${container} {`,
            this.generateDeclarationsForContainer(container),
            `}`
        ].join("\n"))
            .join("\n\n");
        const globalSignatures = this.declarations.containerSignatures[""] || [];
        if (globalSignatures.length > 0) {
            const declarations = this.versionFeatures["global-structs"] === true
                ? this.generateDeclarationsForContainer("")
                : [
                    `interface ${shimGlobalInterfaceName} {`,
                    this.generateDeclarationsForContainer(""),
                    `}`
                ].join("\n");
            return [declarations, externalDeclarations].join("\n\n");
        }
        return externalDeclarations;
    }
    generateDeclarationsForContainer(container) {
        const signatures = new Set(this.declarations.containerSignatures[container]);
        if (container === "" && this.versionFeatures["global-structs"] !== true) {
            container = shimGlobalInterfaceName;
        }
        return Object.entries(this.declarations.signatureDeclarations)
            .filter(([signature]) => signatures.has(signature))
            .map(([signature, declaration]) => {
            const { identifier } = this.identifiers[signature];
            const components = this.generateComponents(declaration, { interfaceName: container });
            return `struct ${identifier} { ${components} }`;
        })
            .join("\n\n");
    }
    generateComponents(declaration, context) {
        return declaration.components
            .map((component) => {
            const { name } = component;
            return `${this.generateType(component, context)} ${name};`;
        })
            .join("\n");
    }
    generateType(variable, context = {}) {
        const signature = this.generateSignature(variable);
        if (!signature) {
            return this.generateElementaryType(variable, context);
        }
        const { type } = variable;
        const { container, identifier } = this.identifiers[signature];
        if (container && container !== context.interfaceName) {
            return type.replace("tuple", `${container}.${identifier}`);
        }
        if (!container && this.versionFeatures["global-structs"] !== true) {
            return type.replace("tuple", `${shimGlobalInterfaceName}.${identifier}`);
        }
        return type.replace("tuple", identifier);
    }
    generateElementaryType(variable, context = {}) {
        // normally we can return the type itself, but functions are a special case
        if (variable.type !== "function") {
            return variable.type;
        }
        // use just the `internalType` field if it exists
        if ("internalType" in variable && variable.internalType) {
            return variable.internalType;
        }
        // otherwise output minimally syntactically-valid syntax with a warning
        return [
            "/* warning: the following type may be incomplete. ",
            "the receiving contract may expect additional input or output parameters. */ ",
            "function() external"
        ].join("");
    }
    generateSignature(variable) {
        if ("signature" in variable && variable.signature) {
            return variable.signature;
        }
        if ("components" in variable && variable.components) {
            return (0, abi_utils_1.abiTupleSignature)(variable.components);
        }
    }
    generateStateMutability(entry) {
        if (entry.stateMutability && entry.stateMutability !== "nonpayable") {
            return entry.stateMutability;
        }
        return "";
    }
    generateFallbackName() {
        switch (this.versionFeatures["fallback-keyword"]) {
            case true: {
                return "fallback";
            }
            case false: {
                return "function";
            }
            case version_features_1.mixed: {
                throw new Error(`Desired Solidity range lacks unambigious fallback syntax.`);
            }
        }
    }
    generateArrayParameterLocation(parameter) {
        switch (this.versionFeatures["array-parameter-location"]) {
            case undefined: {
                return "";
            }
            case version_features_1.mixed: {
                throw new Error(`Desired Solidity range lacks unambiguous location specifier for ` +
                    `parameter of type "${parameter.type}".`);
            }
            default: {
                return this.versionFeatures["array-parameter-location"];
            }
        }
    }
    generateInterface(abi) {
        return [
            `interface ${this.name} {`,
            this.generateDeclarationsForContainer(this.name),
            ``,
            ...abi.map((node) => (0, visitor_1.dispatch)({
                node,
                context: { interfaceName: this.name },
                visitor: this
            })),
            `}`,
        ].join("\n");
    }
}
//# sourceMappingURL=solidity.js.map