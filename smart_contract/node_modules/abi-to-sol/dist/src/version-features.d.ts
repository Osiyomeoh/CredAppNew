import * as semver from "semver";
export declare const mixed: unique symbol;
export declare const allFeatures: {
    readonly "receive-keyword": {
        readonly ">=0.6.0": true;
        readonly "<0.6.0": false;
    };
    readonly "fallback-keyword": {
        readonly ">=0.6.0": true;
        readonly "<0.6.0": false;
    };
    readonly "array-parameter-location": {
        readonly ">=0.7.0": "memory";
        readonly "^0.5.0 || ^0.6.0": "calldata";
        readonly "<0.5.0": undefined;
    };
    readonly "abiencoder-v2": {
        readonly ">=0.8.0": "default";
        readonly "<0.8.0": "experimental";
    };
    readonly "global-structs": {
        readonly ">=0.6.0": true;
        readonly "<0.6.0": false;
    };
    readonly "structs-in-interfaces": {
        readonly ">=0.5.0": true;
        readonly "<0.5.0": false;
    };
    readonly "custom-errors": {
        readonly ">=0.8.4": true;
        readonly "<0.8.4": false;
    };
    readonly "user-defined-value-types": {
        readonly ">=0.8.8": true;
        readonly "<0.8.8": false;
    };
};
export declare type AllFeatures = typeof allFeatures;
export declare type Category = keyof AllFeatures;
export declare type CategoryOptions<C extends Category = Category> = AllFeatures[C];
export declare type CategoryOptionRange<C extends Category = Category> = string & {
    [K in C]: keyof CategoryOptions<K>;
}[C];
export declare type CategoryOption<C extends Category = Category> = {
    [K in C]: CategoryOptions<K>[CategoryOptionRange<K>];
}[C];
export declare type VersionFeatures = {
    [C in Category]: VersionFeature<C>;
};
export declare type VersionFeature<C extends Category> = CategoryOption<C> | typeof mixed;
export declare const forRange: (range: string | semver.Range) => VersionFeatures;
//# sourceMappingURL=version-features.d.ts.map