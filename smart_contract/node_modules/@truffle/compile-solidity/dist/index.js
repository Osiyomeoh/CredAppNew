"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compile = exports.RangeUtils = exports.Parser = exports.run = exports.shouldIncludePath = exports.LoadingStrategies = exports.Cache = exports.Profiler = exports.compileWithPragmaAnalysis = exports.Shims = exports.CompilerSupplier = void 0;
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)("compile");
const contract_sources_1 = __importDefault(require("@truffle/contract-sources"));
const config_1 = __importDefault(require("@truffle/config"));
const profiler_1 = require("./profiler");
const compilerSupplier_1 = require("./compilerSupplier");
const run_1 = require("./run");
const normalizeOptions_1 = require("./normalizeOptions");
const compileWithPragmaAnalysis_1 = require("./compileWithPragmaAnalysis");
const reportSources_1 = require("./reportSources");
const compile_common_1 = require("@truffle/compile-common");
const partition_1 = __importDefault(require("lodash/partition"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const expect = require("@truffle/expect");
var compilerSupplier_2 = require("./compilerSupplier");
Object.defineProperty(exports, "CompilerSupplier", { enumerable: true, get: function () { return compilerSupplier_2.CompilerSupplier; } });
exports.Shims = __importStar(require("./shims"));
var compileWithPragmaAnalysis_2 = require("./compileWithPragmaAnalysis");
Object.defineProperty(exports, "compileWithPragmaAnalysis", { enumerable: true, get: function () { return compileWithPragmaAnalysis_2.compileWithPragmaAnalysis; } });
var profiler_2 = require("./profiler");
Object.defineProperty(exports, "Profiler", { enumerable: true, get: function () { return profiler_2.Profiler; } });
var Cache_1 = require("./compilerSupplier/Cache");
Object.defineProperty(exports, "Cache", { enumerable: true, get: function () { return Cache_1.Cache; } });
exports.LoadingStrategies = __importStar(require("./compilerSupplier/loadingStrategies"));
var shouldIncludePath_1 = require("./profiler/shouldIncludePath");
Object.defineProperty(exports, "shouldIncludePath", { enumerable: true, get: function () { return shouldIncludePath_1.shouldIncludePath; } });
var run_2 = require("./run");
Object.defineProperty(exports, "run", { enumerable: true, get: function () { return run_2.run; } });
var parser_1 = require("./parser");
Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return parser_1.Parser; } });
exports.RangeUtils = __importStar(require("./compilerSupplier/rangeUtils"));
function compileYulPaths(yulPaths, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let yulCompilations = [];
        for (const path of yulPaths) {
            const yulOptions = options.with({ compilationTargets: [path] });
            //load up Yul sources, since they weren't loaded up earlier
            //(we'll just use FS for this rather than going through the resolver,
            //for simplicity, since there are no imports to worry about)
            const yulSource = fs_extra_1.default.readFileSync(path, { encoding: "utf8" });
            debug("Compiling Yul");
            const compilation = yield (0, run_1.run)({ [path]: yulSource }, yulOptions, {
                language: "Yul"
            });
            debug("Yul compiled successfully");
            if (compilation && compilation.contracts.length > 0) {
                yulCompilations.push(compilation);
            }
        }
        if (yulPaths.length > 0 && !options.quiet) {
            //replacement for individual Yul warnings
            options.logger.log("> Warning: Yul is still experimental. Avoid using it in live deployments.");
        }
        return yulCompilations;
    });
}
exports.Compile = {
    // this takes an object with keys being the name and values being source
    // material as well as an options object
    // NOTE: this function does *not* transform the source path prefix to
    // "project:/" before passing to the compiler!
    sources({ sources, options }) {
        return __awaiter(this, void 0, void 0, function* () {
            options = config_1.default.default().merge(options);
            options = (0, normalizeOptions_1.normalizeOptions)(options);
            //note: "solidity" here includes JSON as well!
            const [yulNames, solidityNames] = (0, partition_1.default)(Object.keys(sources), name => name.endsWith(".yul"));
            const soliditySources = Object.assign({}, ...solidityNames.map(name => ({ [name]: sources[name] })));
            let solidityCompilations = [];
            let yulCompilations = [];
            if (solidityNames.length > 0) {
                debug("Compiling Solidity (specified sources)");
                const compilation = yield (0, run_1.run)(soliditySources, options, {
                    noTransform: true
                });
                debug("Compiled Solidity");
                if (compilation && compilation.contracts.length > 0) {
                    solidityCompilations.push(compilation);
                }
            }
            for (const name of yulNames) {
                debug("Compiling Yul (specified sources)");
                const compilation = yield (0, run_1.run)({ [name]: sources[name] }, options, {
                    language: "Yul",
                    noTransform: true
                });
                debug("Compiled Yul");
                if (compilation !== null) {
                    yulCompilations.push(compilation);
                }
            }
            const compilations = [...solidityCompilations, ...yulCompilations];
            return compile_common_1.Compilations.promoteCompileResult({ compilations });
        });
    },
    all(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const paths = [
                ...new Set([
                    ...(yield (0, contract_sources_1.default)(options.contracts_directory)),
                    ...(options.files || [])
                ])
            ];
            return yield exports.Compile.sourcesWithDependencies({
                paths,
                options
            });
        });
    },
    necessary(options) {
        return __awaiter(this, void 0, void 0, function* () {
            options.logger = options.logger || console;
            const paths = yield profiler_1.Profiler.updated(options);
            return yield exports.Compile.sourcesWithDependencies({
                paths,
                options
            });
        });
    },
    sourcesWithDependencies({ paths, options }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.compilers.solc.version === "pragma") {
                return this.sourcesWithPragmaAnalysis({ paths, options });
            }
            options.logger = options.logger || console;
            options.contracts_directory = options.contracts_directory || process.cwd();
            debug("paths: %O", paths);
            expect.options(options, [
                "working_directory",
                "contracts_directory",
                "resolver"
            ]);
            options = config_1.default.default().merge(options);
            options = (0, normalizeOptions_1.normalizeOptions)(options);
            const supplier = new compilerSupplier_1.CompilerSupplier({
                events: options.events,
                solcConfig: options.compilers.solc
            });
            const { solc } = yield supplier.load();
            //note: solidityPaths here still includes JSON as well!
            const [yulPaths, solidityPaths] = (0, partition_1.default)(paths, path => path.endsWith(".yul"));
            debug("invoking profiler");
            //only invoke profiler on Solidity, not Yul
            const { allSources, compilationTargets } = yield profiler_1.Profiler.requiredSources(options.with({
                paths: solidityPaths,
                base_path: options.contracts_directory,
                resolver: options.resolver,
                compiler: {
                    name: "solc",
                    version: solc.version()
                }
            }));
            debug("compilationTargets: %O", compilationTargets);
            // we can exit if there are no Solidity/Yul files to compile since
            // it indicates that we only have Vyper-related JSON
            const solidityTargets = compilationTargets.filter(fileName => fileName.endsWith(".sol"));
            if (solidityTargets.length === 0 && yulPaths.length === 0) {
                return compile_common_1.Compilations.emptyWorkflowCompileResult();
            }
            (0, reportSources_1.reportSources)({ paths: [...compilationTargets, ...yulPaths], options });
            let solidityCompilations = [];
            // only call run if there are sources to run on!
            if (Object.keys(allSources).length > 0) {
                const solidityOptions = options.with({ compilationTargets });
                debug("Compiling Solidity");
                const compilation = yield (0, run_1.run)(allSources, solidityOptions, { solc });
                debug("Solidity compiled successfully");
                if (compilation && compilation.contracts.length > 0) {
                    solidityCompilations.push(compilation);
                }
            }
            const yulCompilations = yield compileYulPaths(yulPaths, options);
            const compilations = [...solidityCompilations, ...yulCompilations];
            return compile_common_1.Compilations.promoteCompileResult({ compilations });
        });
    },
    sourcesWithPragmaAnalysis({ paths, options }) {
        return __awaiter(this, void 0, void 0, function* () {
            const compilationResult = yield (0, compileWithPragmaAnalysis_1.compileWithPragmaAnalysis)({
                paths,
                options
            });
            return compile_common_1.Compilations.promoteCompileResult(compilationResult);
        });
    }
};
//# sourceMappingURL=index.js.map