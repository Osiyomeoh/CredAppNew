"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StrategyCannotListVersionsError = exports.BadInputError = exports.CompilerSupplier = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const semver_1 = __importDefault(require("semver"));
const loadingStrategies_1 = require("./loadingStrategies");
const defaultSolcVersion = "0.5.16";
class CompilerSupplier {
    constructor({ events, solcConfig }) {
        const { version, docker, compilerRoots, dockerTagsUrl, spawn } = solcConfig;
        this.version = version ? version : defaultSolcVersion;
        this.docker = docker;
        this.strategyOptions = {};
        if (version)
            this.strategyOptions.version = this.version;
        if (dockerTagsUrl)
            this.strategyOptions.dockerTagsUrl = dockerTagsUrl;
        if (compilerRoots)
            this.strategyOptions.compilerRoots = compilerRoots;
        if (events)
            this.strategyOptions.events = events;
        if (spawn)
            this.strategyOptions.spawn = spawn;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const userSpecification = this.version;
            let strategy;
            const useDocker = this.docker;
            const useNative = userSpecification === "native";
            const useSpecifiedLocal = userSpecification &&
                (fs_1.default.existsSync(userSpecification) || path_1.default.isAbsolute(userSpecification));
            const isValidVersionRange = semver_1.default.validRange(userSpecification);
            if (useDocker) {
                strategy = new loadingStrategies_1.Docker(this.strategyOptions);
            }
            else if (useNative) {
                strategy = new loadingStrategies_1.Native();
            }
            else if (useSpecifiedLocal) {
                strategy = new loadingStrategies_1.Local();
            }
            else if (isValidVersionRange) {
                strategy = new loadingStrategies_1.VersionRange(this.strategyOptions);
            }
            if (strategy) {
                const solc = yield strategy.load(userSpecification);
                return { solc };
            }
            else {
                throw new BadInputError(userSpecification);
            }
        });
    }
    /**
     * This function lists known solc versions, possibly asynchronously to
     * account for APIs with paginated data (namely, Docker Hub)
     *
     * @return Promise<{
     *           prereleases: AsyncIterable<string>;
     *           releases: AsyncIterable<string>;
     *           latestRelease: string;
     *         }>
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const userSpecification = this.version;
            let strategy;
            const useDocker = this.docker;
            const useNative = userSpecification === "native";
            const useSpecifiedLocal = userSpecification &&
                (fs_1.default.existsSync(userSpecification) || path_1.default.isAbsolute(userSpecification));
            const isValidVersionRange = semver_1.default.validRange(userSpecification) || userSpecification === "pragma";
            if (useDocker) {
                strategy = new loadingStrategies_1.Docker(this.strategyOptions);
            }
            else if (useNative) {
                strategy = new loadingStrategies_1.Native();
            }
            else if (useSpecifiedLocal) {
                strategy = new loadingStrategies_1.Local();
            }
            else if (isValidVersionRange) {
                strategy = new loadingStrategies_1.VersionRange(this.strategyOptions);
            }
            if (!strategy) {
                throw new BadInputError(userSpecification);
            }
            if ("list" in strategy) {
                return yield strategy.list();
            }
            throw new StrategyCannotListVersionsError(strategy.constructor.name);
        });
    }
    static getDefaultVersion() {
        return defaultSolcVersion;
    }
}
exports.CompilerSupplier = CompilerSupplier;
class BadInputError extends Error {
    constructor(input) {
        const message = `Could not find a compiler version matching ${input}. ` +
            `compilers.solc.version option must be a string specifying:\n` +
            `   - a path to a locally installed solcjs\n` +
            `   - a solc version or range (ex: '0.4.22' or '^0.5.0')\n` +
            `   - a docker image name (ex: 'stable')\n` +
            `   - 'native' to use natively installed solc\n`;
        super(message);
    }
}
exports.BadInputError = BadInputError;
class StrategyCannotListVersionsError extends Error {
    constructor(strategyName) {
        super(`Cannot list versions for strategy ${strategyName}`);
    }
}
exports.StrategyCannotListVersionsError = StrategyCannotListVersionsError;
//# sourceMappingURL=index.js.map