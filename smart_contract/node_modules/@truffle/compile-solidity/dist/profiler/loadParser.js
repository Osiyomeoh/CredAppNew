"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadParser = void 0;
const compilerSupplier_1 = require("../compilerSupplier");
const parser_1 = require("../parser");
const semver_1 = __importDefault(require("semver"));
/**
 * Loads solc and wrap it to parse imports rather than performing a full
 * compilation. Returns the wrapped form.
 *
 * This function optionally accepts an `parser` param, whose only possible
 * value is `"solcjs"`. Passing this option indicates that the imports-parser
 * should use a wrapped soljson module instead of whatever normal compiler
 * the user would use. NOTE that as a result, this function may download solc
 * up to twice: first time as usual, to get the specific version, then a second
 * time to get the solcjs of that version.
 */
function loadParser({ events, compilers: { solc: solcConfig } }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { parser } = solcConfig;
        const supplier = new compilerSupplier_1.CompilerSupplier({ events, solcConfig });
        const { solc } = yield supplier.load();
        // if no parser is specified, just use the normal solc
        if (!parser) {
            return makeParseImports(solc);
        }
        // otherwise, there's only one choice...
        if (parser !== "solcjs") {
            throw new Error(`Unsupported parser "${parser}" found in truffle-config.js`);
        }
        // determine normal solc version and then load that version as solcjs
        const result = semver_1.default.coerce(solc.version());
        if (!result) {
            throw new Error(`Could not determine version from ${solc.version}.`);
        }
        const parserSupplier = new compilerSupplier_1.CompilerSupplier({
            events,
            solcConfig: Object.assign(Object.assign({}, solcConfig), { version: result.version, docker: false })
        });
        const { solc: parserSolc } = yield parserSupplier.load();
        return makeParseImports(parserSolc);
    });
}
exports.loadParser = loadParser;
function makeParseImports(parser) {
    const parseImports = (body) => {
        try {
            return parser_1.Parser.parseImports(body, parser);
        }
        catch (err) {
            if (err.message.includes("requires different compiler version")) {
                const contractSolcPragma = err.message.match(/pragma solidity[^;]*/gm);
                // if there's a match provide the helpful error, otherwise return solc's error output
                if (contractSolcPragma) {
                    const contractSolcVer = contractSolcPragma[0];
                    const configSolcVer = semver_1.default.valid(parser.version());
                    err.message = err.message.concat(`\n\nError: Truffle is currently using solc ${configSolcVer}, but one or more of your contracts specify "${contractSolcVer}".\nPlease update your truffle config or pragma statement(s).\n(See https://trufflesuite.com/docs/truffle/reference/configuration#compiler-configuration for information on\nconfiguring Truffle to use a specific solc compiler version.)\n`);
                }
                else {
                    err.message =
                        `Parsing error: ${err.message}.\nThe error occurred ` +
                            `while parsing the following source material: ${body}.`;
                }
            }
            throw err;
        }
    };
    return parseImports;
}
//# sourceMappingURL=loadParser.js.map