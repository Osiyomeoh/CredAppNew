"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ABI = void 0;
const path_1 = __importDefault(require("path"));
const abi_to_sol_1 = require("abi-to-sol");
class ABI {
    constructor(wrappedSource) {
        this.wrappedSource = wrappedSource;
    }
    // requiring artifacts is out of scope for this ResolverSource
    // just return `null` here and let another ResolverSource handle it
    require() {
        return null;
    }
    /**
     * @dev This attempts to resolve an ABI JSON file as Solidity using the
     *      abi-to-sol utility.
     *
     *      Note the **precondition** that `compiler`, if passed, will always
     *      refer to a version of solc, since this ResolverSource is explicitly
     *      disabled for Vyper.
     */
    resolve(importPath, importedFrom = "", options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { compiler } = options;
            if (!compiler || compiler.name !== "solc") {
                //this resolver source for use by solc only!
                //vyper doesn't need it and would be quite thrown off by it
                return { filePath: undefined, body: undefined };
            }
            let filePath;
            let body;
            if (!importPath.endsWith(".json")) {
                return { filePath, body };
            }
            const resolution = yield this.wrappedSource.resolve(importPath, importedFrom, options);
            if (resolution.body === undefined) {
                return { filePath, body };
            }
            const solidityVersion = determineSolidityVersion(compiler);
            ({ filePath, body } = resolution);
            // extract basename twice to support .json and .abi.json
            const name = path_1.default.basename(path_1.default.basename(filePath, ".json"), ".abi");
            try {
                const abi = JSON.parse(body);
                const soliditySource = (0, abi_to_sol_1.generateSolidity)({
                    name,
                    abi,
                    license: "MIT",
                    solidityVersion
                });
                return {
                    filePath,
                    body: soliditySource
                };
            }
            catch (_) {
                //we use this not-quite-empty Solidity to avoid warnings
                //pragma statement introduced in 0.4.0 so can't go earlier
                //than that :)
                const emptySolidity = `
        // SPDX-License-Identifier: MIT
        pragma solidity >=0.4.0;
      `;
                return {
                    filePath,
                    body: emptySolidity
                };
            }
        });
    }
    resolveDependencyPath(importPath, dependencyPath) {
        return __awaiter(this, void 0, void 0, function* () {
            //just defer to wrapped source
            return yield this.wrappedSource.resolveDependencyPath(importPath, dependencyPath);
        });
    }
}
exports.ABI = ABI;
function determineSolidityVersion(compiler) {
    const { version } = compiler;
    // resolver.resolve's `compiler` option may include the full version string,
    // including commit and build target information. abi-to-sol only accepts a
    // short-form version range, i.e. <major>.<minor>.<patch>
    return version.split("+")[0];
}
//# sourceMappingURL=abi.js.map