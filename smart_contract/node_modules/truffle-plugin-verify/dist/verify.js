"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const tunnel_1 = __importDefault(require("tunnel"));
const resolver_1 = __importDefault(require("@truffle/resolver"));
const constants_1 = require("./constants");
const util_1 = require("./util");
const EtherscanVerifier_1 = require("./verifier/EtherscanVerifier");
const SourcifyVerifier_1 = require("./verifier/SourcifyVerifier");
const cliLogger = require('cli-logger');
const logger = cliLogger({ level: 'info' });
module.exports = (config) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // Set debug logging
    if (config.debug)
        logger.level('debug');
    logger.debug('DEBUG logging is turned ON');
    logger.debug(`Running truffle-plugin-verify v${constants_1.VERSION}`);
    if ((_a = config.verify) === null || _a === void 0 ? void 0 : _a.proxy) {
        const { proxy } = config.verify;
        logger.debug('Enable verify proxy ', proxy);
        axios_1.default.interceptors.request.use((conf) => {
            conf.httpsAgent = tunnel_1.default.httpsOverHttp({ proxy });
            conf.proxy = false;
            return conf;
        });
    }
    const options = yield parseConfig(config);
    const verifiers = getVerifiers(config, options);
    // Verify each contract
    const contractNameAddressPairs = config._.slice(1);
    for (const verifier of verifiers) {
        logger.info(`Verifying contracts on ${verifier.name}`);
        try {
            yield verifier.verifyAll(contractNameAddressPairs);
        }
        catch (error) {
            logger.error(`${constants_1.INDENT}${error.message}`);
        }
    }
});
const parseConfig = (config) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c, _d, _e, _f;
    const networkConfig = (_b = config.networks) === null || _b === void 0 ? void 0 : _b[config.network];
    const { chainId, networkId } = yield (0, util_1.getNetwork)(config, logger);
    const explorerUrl = (_d = (_c = networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.verify) === null || _c === void 0 ? void 0 : _c.explorerUrl) !== null && _d !== void 0 ? _d : constants_1.EXPLORER_URLS[Number(chainId)];
    const apiUrl = (_f = (_e = networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.verify) === null || _e === void 0 ? void 0 : _e.apiUrl) !== null && _f !== void 0 ? _f : constants_1.API_URLS[Number(chainId)];
    const apiKey = (0, util_1.getApiKey)(config, apiUrl);
    (0, util_1.enforce)(config._.length > 1, 'No contract name(s) specified', logger);
    (0, util_1.enforce)(networkId !== '*', 'network_id bypassed with "*" in truffle-config.js.', logger);
    const projectDir = config.working_directory;
    const customProxy = config['custom-proxy'];
    let forceConstructorArgsType, forceConstructorArgs;
    if (config.forceConstructorArgs) {
        [forceConstructorArgsType, forceConstructorArgs] = String(config.forceConstructorArgs).split(':');
        (0, util_1.enforce)(forceConstructorArgsType === 'string', 'Force constructor args must be string type', logger);
        logger.debug(`Force custructor args provided: 0x${forceConstructorArgs}`);
    }
    const resolver = new resolver_1.default(config);
    return {
        apiUrl,
        apiKey,
        explorerUrl,
        networkId: Number(networkId),
        chainId: Number(chainId),
        networkName: config.network,
        provider: config.provider,
        projectDir,
        forceConstructorArgs,
        customProxy,
        debug: config.debug,
        resolver,
    };
});
const getVerifiers = (config, options) => {
    const allVerifiersString = constants_1.SUPPORTED_VERIFIERS.join(',');
    const verifierNameString = config.verifiers || allVerifiersString;
    const verifierNames = verifierNameString.split(',').map((name) => name.trim());
    const uniqueVerifierNames = verifierNames.filter((name, i) => verifierNames.indexOf(name) === i);
    const verifiers = [];
    for (const name of uniqueVerifierNames) {
        (0, util_1.enforce)(constants_1.SUPPORTED_VERIFIERS.includes(name), `truffle-plugin-verify has no support for verifier ${name}, supported verifiers: ${allVerifiersString}`);
        if (name === 'etherscan') {
            verifiers.push(new EtherscanVerifier_1.EtherscanVerifier(options));
        }
        if (name === 'sourcify') {
            verifiers.push(new SourcifyVerifier_1.SourcifyVerifier(options));
        }
    }
    return verifiers;
};
