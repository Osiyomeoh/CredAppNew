"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EtherscanVerifier = void 0;
const axios_1 = __importDefault(require("axios"));
const delay_1 = __importDefault(require("delay"));
const querystring_1 = __importDefault(require("querystring"));
const constants_1 = require("../constants");
const util_1 = require("../util");
const AbstractVerifier_1 = require("./AbstractVerifier");
class EtherscanVerifier extends AbstractVerifier_1.AbstractVerifier {
    constructor(options) {
        super(options);
        this.name = options.apiUrl ? (0, util_1.getPlatform)(options.apiUrl).platform : 'etherscan';
    }
    getContractUrl(address) {
        return `${this.options.explorerUrl}/${address}#code`;
    }
    verifyAll(contractNameAddressPairs) {
        const _super = Object.create(null, {
            verifyAll: { get: () => super.verifyAll }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.checkBoundaries();
            yield _super.verifyAll.call(this, contractNameAddressPairs);
        });
    }
    verifyContract(artifact) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkBoundaries();
            const res = yield this.sendVerifyRequest(artifact);
            (0, util_1.enforceOrThrow)(res.data, `Failed to connect to Etherscan API at url ${this.options.apiUrl}`);
            if (res.data.result.includes(constants_1.VerificationStatus.ALREADY_VERIFIED)) {
                return constants_1.VerificationStatus.ALREADY_VERIFIED;
            }
            (0, util_1.enforceOrThrow)(res.data.status === constants_1.RequestStatus.OK, res.data.result);
            return this.verificationStatus(res.data.result);
        });
    }
    verifyProxyContract(proxyArtifact, implementationName, implementationAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkBoundaries();
            if (this.options.customProxy) {
                this.logger.info(`Verifying custom proxy contract ${this.options.customProxy} at ${proxyArtifact.networks[`${this.options.networkId}`].address}`);
                const status = yield this.verifyContract(proxyArtifact);
                if (status.includes(constants_1.VerificationStatus.FAILED))
                    return status;
            }
            const implementationArtifact = (0, util_1.deepCopy)((0, util_1.getArtifact)(implementationName, this.options, this.logger));
            implementationArtifact.networks[`${this.options.networkId}`] = {
                address: implementationAddress,
            };
            this.logger.info(`Verifying proxy implementation ${implementationName} at ${implementationAddress}`);
            const status = yield this.verifyContract(implementationArtifact);
            if (!status.includes(constants_1.VerificationStatus.FAILED)) {
                this.logger.info('Linking proxy and implementation addresses');
                yield this.verifyProxy(proxyArtifact.networks[`${this.options.networkId}`].address);
            }
            return status;
        });
    }
    sendVerifyRequest(artifact) {
        return __awaiter(this, void 0, void 0, function* () {
            const compilerVersion = (0, util_1.extractCompilerVersion)(artifact);
            const encodedConstructorArgs = this.options.forceConstructorArgs !== undefined
                ? this.options.forceConstructorArgs
                : yield this.fetchConstructorValues(artifact);
            const inputJSON = yield (0, util_1.getInputJSON)(artifact, this.options, this.logger);
            // Remove the 'project:' prefix that was added in Truffle v5.3.14
            const relativeFilePath = artifact.ast.absolutePath.replace('project:', '');
            const postQueries = {
                apikey: this.options.apiKey,
                module: 'contract',
                action: 'verifysourcecode',
                contractaddress: artifact.networks[`${this.options.networkId}`].address,
                sourceCode: JSON.stringify(inputJSON),
                codeformat: 'solidity-standard-json-input',
                contractname: `${relativeFilePath}:${artifact.contractName}`,
                compilerversion: compilerVersion,
                constructorArguements: encodedConstructorArgs,
            };
            try {
                this.logger.debug('Sending verify request with POST arguments:');
                (0, util_1.logObject)(this.logger, 'debug', postQueries, 2);
                return yield axios_1.default.post(this.options.apiUrl, querystring_1.default.stringify(postQueries));
            }
            catch (error) {
                this.logger.debug(error.message);
                throw new Error(`Failed to connect to Etherscan API at url ${this.options.apiUrl}`);
            }
        });
    }
    fetchConstructorValues(artifact) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractAddress = artifact.networks[`${this.options.networkId}`].address;
            // Fetch the contract creation transaction to extract the input data
            let res;
            try {
                const qs = querystring_1.default.stringify({
                    apiKey: this.options.apiKey,
                    module: 'account',
                    action: 'txlist',
                    address: contractAddress,
                    page: 1,
                    sort: 'asc',
                    offset: 1,
                });
                const url = `${this.options.apiUrl}?${qs}`;
                this.logger.debug(`Retrieving constructor parameters from ${url}`);
                res = yield axios_1.default.get(url);
            }
            catch (error) {
                this.logger.debug(error.message);
                throw new Error(`Failed to connect to Etherscan API at url ${this.options.apiUrl}`);
            }
            // The last part of the transaction data is the constructor arguments
            // If it can't be accessed for any reason, try using empty constructor arguments
            if (res.data && res.data.status === constants_1.RequestStatus.OK && res.data.result[0] !== undefined) {
                const constructorArgs = res.data.result[0].input.substring(artifact.bytecode.length);
                this.logger.debug(`Constructor parameters retrieved: 0x${constructorArgs}`);
                return constructorArgs;
            }
            else {
                this.logger.debug('Could not retrieve constructor parameters, using empty parameters as fallback');
                return '';
            }
        });
    }
    verificationStatus(guid, action = 'checkverifystatus') {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Checking status of verification request ${guid}`);
            // Retry API call every second until status is no longer pending
            while (true) {
                yield (0, delay_1.default)(1000);
                try {
                    const qs = querystring_1.default.stringify({
                        apiKey: this.options.apiKey,
                        module: 'contract',
                        action,
                        guid,
                    });
                    const verificationResult = yield axios_1.default.get(`${this.options.apiUrl}?${qs}`);
                    if (!verificationResult.data.result.includes(constants_1.VerificationStatus.PENDING)) {
                        return verificationResult.data.result;
                    }
                }
                catch (error) {
                    this.logger.debug(error.message);
                    throw new Error(`Failed to connect to Etherscan API at url ${this.options.apiUrl}`);
                }
            }
        });
    }
    sendProxyVerifyRequest(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const postQueries = { address };
            const qs = querystring_1.default.stringify({
                apiKey: this.options.apiKey,
                module: 'contract',
                action: 'verifyproxycontract',
            });
            try {
                this.logger.debug(`Sending verify proxy request to ${this.options.apiUrl}?${qs} with POST arguments:`);
                (0, util_1.logObject)(this.logger, 'debug', postQueries, 2);
                return yield axios_1.default.post(`${this.options.apiUrl}?${qs}`, querystring_1.default.stringify(postQueries));
            }
            catch (error) {
                this.logger.info(error.message);
                throw new Error(`Failed to connect to Etherscan API at url ${this.options.apiUrl}`);
            }
        });
    }
    verifyProxy(proxyAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendProxyVerifyRequest(proxyAddress);
            (0, util_1.enforceOrThrow)(res.data, `Failed to connect to Etherscan API at url ${this.options.apiUrl}`);
            (0, util_1.enforceOrThrow)(res.data.status === constants_1.RequestStatus.OK, res.data.result);
            const status = yield this.verificationStatus(res.data.result, 'checkproxyverification');
            this.logger.debug(status);
        });
    }
    checkBoundaries() {
        (0, util_1.enforceOrThrow)(this.options.apiUrl, `Etherscan has no support for network ${this.options.networkName} with chain id ${this.options.chainId}`);
        const { platform, subPlatform } = (0, util_1.getPlatform)(this.options.apiUrl);
        (0, util_1.enforceOrThrow)(this.options.apiKey, `No ${platform} or ${subPlatform}_${platform} API Key provided`);
    }
}
exports.EtherscanVerifier = EtherscanVerifier;
