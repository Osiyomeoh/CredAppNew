{"ast":null,"code":"/*\r\n    This file is part of web3.js.\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\n/**\r\n * @file Registry.js\r\n *\r\n * @author Samuel Furter <samuel@ethereum.org>\r\n * @date 2018\r\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar Contract = require('web3-eth-contract');\nvar namehash = require('eth-ens-namehash');\nvar PromiEvent = require('web3-core-promievent');\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar REGISTRY_ABI = require('../resources/ABI/Registry');\nvar RESOLVER_ABI = require('../resources/ABI/Resolver');\n\n/**\r\n * A wrapper around the ENS registry contract.\r\n *\r\n * @method Registry\r\n * @param {Ens} ens\r\n * @constructor\r\n */\nfunction Registry(ens) {\n  var self = this;\n  this.ens = ens;\n  this.contract = ens.checkNetwork().then(function (address) {\n    var contract = new Contract(REGISTRY_ABI, address);\n    contract.setProvider(self.ens.eth.currentProvider);\n    return contract;\n  });\n}\n\n/**\r\n * Returns the address of the owner of an ENS name.\r\n *\r\n * @deprecated Please use the \"getOwner\" method instead of \"owner\"\r\n *\r\n * @method owner\r\n *\r\n * @param {string} name\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {Promise<string>}\r\n */\nRegistry.prototype.owner = function (name, callback) {\n  console.warn('Deprecated: Please use the \"getOwner\" method instead of \"owner\".');\n  return this.getOwner(name, callback);\n};\n\n/**\r\n * Returns the address of the owner of an ENS name.\r\n *\r\n * @method getOwner\r\n *\r\n * @param {string} name\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {Promise<string>}\r\n */\nRegistry.prototype.getOwner = function (name, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.owner(namehash.hash(name)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Returns the address of the owner of an ENS name.\r\n *\r\n * @method setOwner\r\n *\r\n * @param {string} name\r\n * @param {string} address\r\n * @param {TransactionConfig} txConfig\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\r\n */\nRegistry.prototype.setOwner = function (name, address, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setOwner(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Returns the TTL of the given node by his name\r\n *\r\n * @method getTTL\r\n *\r\n * @param {string} name\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returnss {Promise<string>}\r\n */\nRegistry.prototype.getTTL = function (name, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.ttl(namehash.hash(name)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Returns the address of the owner of an ENS name.\r\n *\r\n * @method setTTL\r\n *\r\n * @param {string} name\r\n * @param {number} ttl\r\n * @param {TransactionConfig} txConfig\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\r\n */\nRegistry.prototype.setTTL = function (name, ttl, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setTTL(namehash.hash(name), ttl).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Returns the address of the owner of an ENS name.\r\n *\r\n * @method setSubnodeOwner\r\n *\r\n * @param {string} name\r\n * @param {string} label\r\n * @param {string} address\r\n * @param {TransactionConfig} txConfig\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\r\n */\nRegistry.prototype.setSubnodeOwner = function (name, label, address, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  if (!utils.isHexStrict(label)) {\n    label = utils.sha3(label);\n  }\n  this.contract.then(function (contract) {\n    return contract.methods.setSubnodeOwner(namehash.hash(name), label, formatters.inputAddressFormatter(address)).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Sets the owner, resolver, and TTL for an ENS record in a single operation.\r\n *\r\n * @method setRecord\r\n *\r\n * @param {string} name\r\n * @param {string} owner\r\n * @param {string} resolver\r\n * @param {string | number} ttl\r\n * @param {TransactionConfig} txConfig\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\r\n */\nRegistry.prototype.setRecord = function (name, owner, resolver, ttl, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setRecord(namehash.hash(name), formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Sets the owner, resolver and TTL for a subdomain, creating it if necessary.\r\n *\r\n * @method setSubnodeRecord\r\n *\r\n * @param {string} name\r\n * @param {string} label\r\n * @param {string} owner\r\n * @param {string} resolver\r\n * @param {string | number} ttl\r\n * @param {TransactionConfig} txConfig\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\r\n */\nRegistry.prototype.setSubnodeRecord = function (name, label, owner, resolver, ttl, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  if (!utils.isHexStrict(label)) {\n    label = utils.sha3(label);\n  }\n  this.contract.then(function (contract) {\n    return contract.methods.setSubnodeRecord(namehash.hash(name), label, formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Sets or clears an approval by the given operator.\r\n *\r\n * @method setApprovalForAll\r\n *\r\n * @param {string} operator\r\n * @param {boolean} approved\r\n * @param {TransactionConfig} txConfig\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\r\n */\nRegistry.prototype.setApprovalForAll = function (operator, approved, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setApprovalForAll(formatters.inputAddressFormatter(operator), approved).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Returns true if the operator is approved\r\n *\r\n * @method isApprovedForAll\r\n *\r\n * @param {string} owner\r\n * @param {string} operator\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {Promise<boolean>}\r\n */\nRegistry.prototype.isApprovedForAll = function (owner, operator, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.isApprovedForAll(formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(operator)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Returns true if the record exists\r\n *\r\n * @method recordExists\r\n *\r\n * @param {string} name\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {Promise<boolean>}\r\n */\nRegistry.prototype.recordExists = function (name, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.recordExists(namehash.hash(name)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\n/**\r\n * Returns the resolver contract associated with a name.\r\n *\r\n * @deprecated Please use the \"getResolver\" method instead of \"resolver\"\r\n *\r\n * @method resolver\r\n *\r\n * @param {string} name\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {Promise<Contract>}\r\n */\nRegistry.prototype.resolver = function (name, callback) {\n  console.warn('Deprecated: Please use the \"getResolver\" method instead of \"resolver\".');\n  return this.getResolver(name, callback);\n};\n\n/**\r\n * Returns the resolver contract associated with a name.\r\n *\r\n * @method getResolver\r\n *\r\n * @param {string} name\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {Promise<Contract>}\r\n */\nRegistry.prototype.getResolver = function (name, callback) {\n  var self = this;\n  return this.contract.then(function (contract) {\n    return contract.methods.resolver(namehash.hash(name)).call();\n  }).then(function (address) {\n    var contract = new Contract(RESOLVER_ABI, address);\n    contract.setProvider(self.ens.eth.currentProvider);\n    if (_.isFunction(callback)) {\n      // It's required to pass the contract to the first argument to be backward compatible and to have the required consistency\n      callback(contract, contract);\n      return;\n    }\n    return contract;\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    throw error;\n  });\n};\n\n/**\r\n * Returns the address of the owner of an ENS name.\r\n *\r\n * @method setResolver\r\n *\r\n * @param {string} name\r\n * @param {string} address\r\n * @param {TransactionConfig} txConfig\r\n * @param {function} callback\r\n *\r\n * @callback callback callback(error, result)\r\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\r\n */\nRegistry.prototype.setResolver = function (name, address, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setResolver(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\nmodule.exports = Registry;","map":null,"metadata":{},"sourceType":"script"}