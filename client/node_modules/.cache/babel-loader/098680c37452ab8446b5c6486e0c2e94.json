{"ast":null,"code":"var capability = require('./capability');\nvar inherits = require('inherits');\nvar stream = require('readable-stream');\nvar rStates = exports.readyStates = {\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n};\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {\n  var self = this;\n  stream.Readable.call(self);\n  self._mode = mode;\n  self.headers = {};\n  self.rawHeaders = [];\n  self.trailers = {};\n  self.rawTrailers = [];\n\n  // Fake the 'close' event, but only once 'end' fires\n  self.on('end', function () {\n    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n    process.nextTick(function () {\n      self.emit('close');\n    });\n  });\n  if (mode === 'fetch') {\n    var read = function read() {\n      reader.read().then(function (result) {\n        if (self._destroyed) return;\n        if (result.done) {\n          global.clearTimeout(fetchTimer);\n          self.push(null);\n          return;\n        }\n        self.push(new Buffer(result.value));\n        read();\n      }).catch(function (err) {\n        global.clearTimeout(fetchTimer);\n        if (!self._destroyed) self.emit('error', err);\n      });\n    };\n    self._fetchResponse = response;\n    self.url = response.url;\n    self.statusCode = response.status;\n    self.statusMessage = response.statusText;\n    response.headers.forEach(function (header, key) {\n      self.headers[key.toLowerCase()] = header;\n      self.rawHeaders.push(key, header);\n    });\n    if (capability.writableStream) {\n      var writable = new WritableStream({\n        write: function write(chunk) {\n          return new Promise(function (resolve, reject) {\n            if (self._destroyed) {\n              reject();\n            } else if (self.push(new Buffer(chunk))) {\n              resolve();\n            } else {\n              self._resumeFetch = resolve;\n            }\n          });\n        },\n        close: function close() {\n          global.clearTimeout(fetchTimer);\n          if (!self._destroyed) self.push(null);\n        },\n        abort: function abort(err) {\n          if (!self._destroyed) self.emit('error', err);\n        }\n      });\n      try {\n        response.body.pipeTo(writable).catch(function (err) {\n          global.clearTimeout(fetchTimer);\n          if (!self._destroyed) self.emit('error', err);\n        });\n        return;\n      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n    }\n    // fallback for when writableStream or pipeTo aren't available\n    var reader = response.body.getReader();\n    read();\n  } else {\n    self._xhr = xhr;\n    self._pos = 0;\n    self.url = xhr.responseURL;\n    self.statusCode = xhr.status;\n    self.statusMessage = xhr.statusText;\n    var headers = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n    headers.forEach(function (header) {\n      var matches = header.match(/^([^:]+):\\s*(.*)/);\n      if (matches) {\n        var key = matches[1].toLowerCase();\n        if (key === 'set-cookie') {\n          if (self.headers[key] === undefined) {\n            self.headers[key] = [];\n          }\n          self.headers[key].push(matches[2]);\n        } else if (self.headers[key] !== undefined) {\n          self.headers[key] += ', ' + matches[2];\n        } else {\n          self.headers[key] = matches[2];\n        }\n        self.rawHeaders.push(matches[1], matches[2]);\n      }\n    });\n    self._charset = 'x-user-defined';\n    if (!capability.overrideMimeType) {\n      var mimeType = self.rawHeaders['mime-type'];\n      if (mimeType) {\n        var charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/);\n        if (charsetMatch) {\n          self._charset = charsetMatch[1].toLowerCase();\n        }\n      }\n      if (!self._charset) self._charset = 'utf-8'; // best guess\n    }\n  }\n};\n\ninherits(IncomingMessage, stream.Readable);\nIncomingMessage.prototype._read = function () {\n  var self = this;\n  var resolve = self._resumeFetch;\n  if (resolve) {\n    self._resumeFetch = null;\n    resolve();\n  }\n};\nIncomingMessage.prototype._onXHRProgress = function () {\n  var self = this;\n  var xhr = self._xhr;\n  var response = null;\n  switch (self._mode) {\n    case 'text:vbarray':\n      // For IE9\n      if (xhr.readyState !== rStates.DONE) break;\n      try {\n        // This fails in IE8\n        response = new global.VBArray(xhr.responseBody).toArray();\n      } catch (e) {}\n      if (response !== null) {\n        self.push(new Buffer(response));\n        break;\n      }\n    // Falls through in IE8\t\n    case 'text':\n      try {\n        // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n        response = xhr.responseText;\n      } catch (e) {\n        self._mode = 'text:vbarray';\n        break;\n      }\n      if (response.length > self._pos) {\n        var newData = response.substr(self._pos);\n        if (self._charset === 'x-user-defined') {\n          var buffer = new Buffer(newData.length);\n          for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;\n          self.push(buffer);\n        } else {\n          self.push(newData, self._charset);\n        }\n        self._pos = response.length;\n      }\n      break;\n    case 'arraybuffer':\n      if (xhr.readyState !== rStates.DONE || !xhr.response) break;\n      response = xhr.response;\n      self.push(new Buffer(new Uint8Array(response)));\n      break;\n    case 'moz-chunked-arraybuffer':\n      // take whole\n      response = xhr.response;\n      if (xhr.readyState !== rStates.LOADING || !response) break;\n      self.push(new Buffer(new Uint8Array(response)));\n      break;\n    case 'ms-stream':\n      response = xhr.response;\n      if (xhr.readyState !== rStates.LOADING) break;\n      var reader = new global.MSStreamReader();\n      reader.onprogress = function () {\n        if (reader.result.byteLength > self._pos) {\n          self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));\n          self._pos = reader.result.byteLength;\n        }\n      };\n      reader.onload = function () {\n        self.push(null);\n      };\n      // reader.onerror = ??? // TODO: this\n      reader.readAsArrayBuffer(response);\n      break;\n  }\n\n  // The ms-stream case handles end separately in reader.onload()\n  if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n    self.push(null);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}