{"ast":null,"code":"/*\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n */\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2018\r\n */\n\nvar Buffer = require('buffer').Buffer;\nvar _ = require('underscore');\nvar utils = require('web3-utils');\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\nvar ParamType = require('@ethersproject/abi').ParamType;\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n  return value;\n});\n\n// result method\nfunction Result() {}\n\n/**\r\n * ABICoder prototype should be used to encode/decode solidity params of any type\r\n */\nvar ABICoder = function ABICoder() {};\n\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeFunctionSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n  return utils.sha3(functionName).slice(0, 10);\n};\n\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeEventSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n  return utils.sha3(functionName);\n};\n\n/**\r\n * Should be used to encode plain param\r\n *\r\n * @method encodeParameter\r\n *\r\n * @param {String|Object} type\r\n * @param {any} param\r\n *\r\n * @return {String} encoded plain param\r\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n\n/**\r\n * Should be used to encode list of params\r\n *\r\n * @method encodeParameters\r\n *\r\n * @param {Array<String|Object>} types\r\n * @param {Array<any>} params\r\n *\r\n * @return {String} encoded list of params\r\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n  var self = this;\n  types = self.mapTypes(types);\n  params = params.map(function (param, index) {\n    var type = types[index];\n    if (typeof type === 'object' && type.type) {\n      // We may get a named type of shape {name, type}\n      type = type.type;\n    }\n    param = self.formatParam(type, param);\n\n    // Format params for tuples\n    if (typeof type === 'string' && type.includes('tuple')) {\n      var _coder = ethersAbiCoder._getCoder(ParamType.from(type));\n      var modifyParams = function modifyParams(coder, param) {\n        if (coder.name === 'array') {\n          return param.map(function (p) {\n            return modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p);\n          });\n        }\n        coder.coders.forEach(function (c, i) {\n          if (c.name === 'tuple') {\n            modifyParams(c, param[i]);\n          } else {\n            param[i] = self.formatParam(c.name, param[i]);\n          }\n        });\n      };\n      modifyParams(_coder, param);\n    }\n    return param;\n  });\n  return ethersAbiCoder.encode(types, params);\n};\n\n/**\r\n * Map types if simplified format is used\r\n *\r\n * @method mapTypes\r\n * @param {Array} types\r\n * @return {Array}\r\n */\nABICoder.prototype.mapTypes = function (types) {\n  var self = this;\n  var mappedTypes = [];\n  types.forEach(function (type) {\n    // Remap `function` type params to bytes24 since Ethers does not\n    // recognize former type. Solidity docs say `Function` is a bytes24\n    // encoding the contract address followed by the function selector hash.\n    if (typeof type === 'object' && type.type === 'function') {\n      type.type = \"bytes24\";\n    }\n    if (self.isSimplifiedStructFormat(type)) {\n      var structName = Object.keys(type)[0];\n      mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n        components: self.mapStructToCoderFormat(type[structName])\n      }));\n      return;\n    }\n    mappedTypes.push(type);\n  });\n  return mappedTypes;\n};\n\n/**\r\n * Check if type is simplified struct format\r\n *\r\n * @method isSimplifiedStructFormat\r\n * @param {string | Object} type\r\n * @returns {boolean}\r\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n\n/**\r\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n *\r\n * @method mapStructNameAndType\r\n * @param {string} structName\r\n * @return {{type: string, name: *}}\r\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n  var type = 'tuple';\n  if (structName.indexOf('[]') > -1) {\n    type = 'tuple[]';\n    structName = structName.slice(0, -2);\n  }\n  return {\n    type: type,\n    name: structName\n  };\n};\n\n/**\r\n * Maps the simplified format in to the expected format of the ABICoder\r\n *\r\n * @method mapStructToCoderFormat\r\n * @param {Object} struct\r\n * @return {Array}\r\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n  var self = this;\n  var components = [];\n  Object.keys(struct).forEach(function (key) {\n    if (typeof struct[key] === 'object') {\n      components.push(Object.assign(self.mapStructNameAndType(key), {\n        components: self.mapStructToCoderFormat(struct[key])\n      }));\n      return;\n    }\n    components.push({\n      name: key,\n      type: struct[key]\n    });\n  });\n  return components;\n};\n\n/**\r\n * Handle some formatting of params for backwards compatability with Ethers V4\r\n *\r\n * @method formatParam\r\n * @param {String} - type\r\n * @param {any} - param\r\n * @return {any} - The formatted param\r\n */\nABICoder.prototype.formatParam = function (type, param) {\n  var _this2 = this;\n  var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n  var paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n  var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n  var paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n\n  // Format BN to string\n  if (utils.isBN(param) || utils.isBigNumber(param)) {\n    return param.toString(10);\n  }\n  if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n    return param.map(function (p) {\n      return _this2.formatParam(type.replace('[]', ''), p);\n    });\n  }\n\n  // Format correct width for u?int[0-9]*\n  var match = type.match(paramTypeNumber);\n  if (match) {\n    var size = parseInt(match[2] || \"256\");\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      param = utils.leftPad(param, size);\n    }\n  }\n\n  // Format correct length for bytes[0-9]+\n  match = type.match(paramTypeBytes);\n  if (match) {\n    if (Buffer.isBuffer(param)) {\n      param = utils.toHex(param);\n    }\n\n    // format to correct length\n    var _size = parseInt(match[1]);\n    if (_size) {\n      var maxSize = _size * 2;\n      if (param.substring(0, 2) === '0x') {\n        maxSize += 2;\n      }\n      if (param.length < maxSize) {\n        // pad to correct length\n        param = utils.rightPad(param, _size * 2);\n      }\n    }\n\n    // format odd-length bytes to even-length\n    if (param.length % 2 === 1) {\n      param = '0x0' + param.substring(2);\n    }\n  }\n  return param;\n};\n\n/**\r\n * Encodes a function call from its json interface and parameters.\r\n *\r\n * @method encodeFunctionCall\r\n * @param {Array} jsonInterface\r\n * @param {Array} params\r\n * @return {String} The encoded ABI for this function call\r\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n\n/**\r\n * Should be used to decode bytes to plain param\r\n *\r\n * @method decodeParameter\r\n * @param {String} type\r\n * @param {String} bytes\r\n * @return {Object} plain param\r\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  return this.decodeParameters([type], bytes)[0];\n};\n\n/**\r\n * Should be used to decode list of params\r\n *\r\n * @method decodeParameter\r\n * @param {Array} outputs\r\n * @param {String} bytes\r\n * @return {Array} array of plain params\r\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n    throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n  }\n  var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  outputs.forEach(function (output, i) {\n    var decodedValue = res[returnValue.__length__];\n    decodedValue = decodedValue === '0x' ? null : decodedValue;\n    returnValue[i] = decodedValue;\n    if (_.isObject(output) && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n\n/**\r\n * Decodes events non- and indexed parameters.\r\n *\r\n * @method decodeLog\r\n * @param {Object} inputs\r\n * @param {String} data\r\n * @param {Array} topics\r\n * @return {Array} array of plain params\r\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  var _this = this;\n  topics = _.isArray(topics) ? topics : [topics];\n  data = data || '';\n  var notIndexedInputs = [];\n  var indexedParams = [];\n  var topicCount = 0;\n\n  // TODO check for anonymous logs?\n\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n        return input.type.indexOf(staticType) !== -1;\n      }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n      topicCount++;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  var nonIndexedData = data;\n  var notIndexedParams = nonIndexedData ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n    if (typeof notIndexedParams[i] !== 'undefined') {\n      returnValue[i] = notIndexedParams[i];\n    }\n    if (typeof indexedParams[i] !== 'undefined') {\n      returnValue[i] = indexedParams[i];\n    }\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;","map":null,"metadata":{},"sourceType":"script"}