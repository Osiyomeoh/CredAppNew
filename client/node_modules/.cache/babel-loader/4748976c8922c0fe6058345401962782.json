{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\USER\\\\Documents\\\\CredAppNew\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\USER\\\\Documents\\\\CredAppNew\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar mh = require('multihashes');\nvar multibase = require('multibase');\nvar multicodec = require('multicodec');\nvar codecs = require('multicodec/src/base-table.json');\nvar CIDUtil = require('./cid-util');\nvar withIs = require('class-is');\n\n/**\r\n * @typedef {Object} SerializedCID\r\n * @param {string} codec\r\n * @param {number} version\r\n * @param {Buffer} multihash\r\n */\n\n/**\r\n * Test if the given input is a CID.\r\n * @function isCID\r\n * @memberof CID\r\n * @static\r\n * @param {any} other\r\n * @returns {bool}\r\n */\n\n/**\r\n * Class representing a CID `<mbase><version><mcodec><mhash>`\r\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\r\n * @class CID\r\n */\nvar CID = /*#__PURE__*/function () {\n  /**\r\n   * Create a new CID.\r\n   *\r\n   * The algorithm for argument input is roughly:\r\n   * ```\r\n   * if (cid)\r\n   *   -> create a copy\r\n   * else if (str)\r\n   *   if (1st char is on multibase table) -> CID String\r\n   *   else -> bs58 encoded multihash\r\n   * else if (Buffer)\r\n   *   if (1st byte is 0 or 1) -> CID\r\n   *   else -> multihash\r\n   * else if (Number)\r\n   *   -> construct CID by parts\r\n   * ```\r\n   *\r\n   * @param {string|Buffer|CID} version\r\n   * @param {string} [codec]\r\n   * @param {Buffer} [multihash]\r\n   * @param {string} [multibaseName]\r\n   *\r\n   * @example\r\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\r\n   * new CID(<cidStr>)\r\n   * new CID(<cid.buffer>)\r\n   * new CID(<multihash>)\r\n   * new CID(<bs58 encoded multihash>)\r\n   * new CID(<cid>)\r\n   */\n  function CID(version, codec, multihash, multibaseName) {\n    _classCallCheck(this, CID);\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      var cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = Buffer.from(cid.multihash);\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      var baseName = multibase.isEncoded(version);\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        var _cid = multibase.decode(version);\n        this.version = parseInt(_cid.slice(0, 1).toString('hex'), 16);\n        this.codec = multicodec.getCodec(_cid.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n    if (Buffer.isBuffer(version)) {\n      var firstByte = version.slice(0, 1);\n      var v = parseInt(firstByte.toString('hex'), 16);\n      if (v === 1) {\n        // version is a CID buffer\n        var _cid2 = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(_cid2.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid2.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash buffer, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      return;\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    /**\r\n     * @type {number}\r\n     */\n    this.version = version;\n\n    /**\r\n     * @type {string}\r\n     */\n    this.codec = codec;\n\n    /**\r\n     * @type {Buffer}\r\n     */\n    this.multihash = multihash;\n\n    /**\r\n     * @type {string}\r\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n\n  /**\r\n   * The CID as a `Buffer`\r\n   *\r\n   * @return {Buffer}\r\n   * @readonly\r\n   *\r\n   * @memberOf CID\r\n   */\n  _createClass(CID, [{\n    key: \"toV0\",\n    /**\r\n     * Convert to a CID of version `0`.\r\n     *\r\n     * @returns {CID}\r\n     */\n    value: function toV0() {\n      if (this.codec !== 'dag-pb') {\n        throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n      }\n      var _mh$decode = mh.decode(this.multihash),\n        name = _mh$decode.name,\n        length = _mh$decode.length;\n      if (name !== 'sha2-256') {\n        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n      }\n      if (length !== 32) {\n        throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n      }\n      return new _CID(0, this.codec, this.multihash);\n    }\n    /**\r\n     * Convert to a CID of version `1`.\r\n     *\r\n     * @returns {CID}\r\n     */\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      return new _CID(1, this.codec, this.multihash);\n    }\n    /**\r\n     * Encode the CID into a string.\r\n     *\r\n     * @param {string} [base=this.multibaseName] - Base encoding to use.\r\n     * @returns {string}\r\n     */\n  }, {\n    key: \"toBaseEncodedString\",\n    value: function toBaseEncodedString() {\n      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n      if (this.string && base === this.multibaseName) {\n        return this.string;\n      }\n      var str = null;\n      if (this.version === 0) {\n        if (base !== 'base58btc') {\n          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n        }\n        str = mh.toB58String(this.multihash);\n      } else if (this.version === 1) {\n        str = multibase.encode(base, this.buffer).toString();\n      } else {\n        throw new Error('unsupported version');\n      }\n      if (base === this.multibaseName) {\n        // cache the string value\n        Object.defineProperty(this, 'string', {\n          value: str\n        });\n      }\n      return str;\n    }\n    /**\r\n     * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\r\n     *\r\n     * @returns {String}\r\n     */\n  }, {\n    key: Symbol.for('nodejs.util.inspect.custom'),\n    value: function value() {\n      return 'CID(' + this.toString() + ')';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(base) {\n      return this.toBaseEncodedString(base);\n    }\n    /**\r\n     * Serialize to a plain object.\r\n     *\r\n     * @returns {SerializedCID}\r\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        codec: this.codec,\n        version: this.version,\n        hash: this.multihash\n      };\n    }\n    /**\r\n     * Compare equality with another CID.\r\n     *\r\n     * @param {CID} other\r\n     * @returns {bool}\r\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);\n    }\n    /**\r\n     * Test if the given input is a valid CID object.\r\n     * Throws if it is not.\r\n     *\r\n     * @param {any} other\r\n     * @returns {void}\r\n     */\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      var buffer = this._buffer;\n      if (!buffer) {\n        if (this.version === 0) {\n          buffer = this.multihash;\n        } else if (this.version === 1) {\n          buffer = Buffer.concat([Buffer.from('01', 'hex'), multicodec.getCodeVarint(this.codec), this.multihash]);\n        } else {\n          throw new Error('unsupported version');\n        }\n\n        // Cache this buffer so it doesn't have to be recreated\n        Object.defineProperty(this, '_buffer', {\n          value: buffer\n        });\n      }\n      return buffer;\n    }\n    /**\r\n     * Get the prefix of the CID.\r\n     *\r\n     * @returns {Buffer}\r\n     * @readonly\r\n     */\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      return Buffer.concat([Buffer.from(\"0\".concat(this.version), 'hex'), multicodec.getCodeVarint(this.codec), mh.prefix(this.multihash)]);\n    }\n  }], [{\n    key: \"validateCID\",\n    value: function validateCID(other) {\n      var errorMsg = CIDUtil.checkCIDComponents(other);\n      if (errorMsg) {\n        throw new Error(errorMsg);\n      }\n    }\n  }]);\n  return CID;\n}();\nvar _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":null,"metadata":{},"sourceType":"script"}