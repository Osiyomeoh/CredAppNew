{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _activeElement = _interopRequireDefault(require(\"dom-helpers/activeElement\"));\nvar _contains = _interopRequireDefault(require(\"dom-helpers/query/contains\"));\nvar _inDOM = _interopRequireDefault(require(\"dom-helpers/util/inDOM\"));\nvar _listen = _interopRequireDefault(require(\"dom-helpers/events/listen\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _componentOrElement = _interopRequireDefault(require(\"prop-types-extra/lib/componentOrElement\"));\nvar _elementType = _interopRequireDefault(require(\"prop-types-extra/lib/elementType\"));\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\nvar _ModalManager = _interopRequireDefault(require(\"./ModalManager\"));\nvar _Portal = _interopRequireDefault(require(\"./Portal\"));\nvar _getContainer = _interopRequireDefault(require(\"./utils/getContainer\"));\nvar _ownerDocument = _interopRequireDefault(require(\"./utils/ownerDocument\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nvar modalManager = new _ModalManager.default();\nfunction omitProps(props, propTypes) {\n  var keys = Object.keys(props);\n  var newProps = {};\n  keys.map(function (prop) {\n    if (!Object.prototype.hasOwnProperty.call(propTypes, prop)) {\n      newProps[prop] = props[prop];\n    }\n  });\n  return newProps;\n}\n/**\r\n * Love them or hate them, `<Modal />` provides a solid foundation for creating dialogs, lightboxes, or whatever else.\r\n * The Modal component renders its `children` node in front of a backdrop component.\r\n *\r\n * The Modal offers a few helpful features over using just a `<Portal/>` component and some styles:\r\n *\r\n * - Manages dialog stacking when one-at-a-time just isn't enough.\r\n * - Creates a backdrop, for disabling interaction below the modal.\r\n * - It properly manages focus; moving to the modal content, and keeping it there until the modal is closed.\r\n * - It disables scrolling of the page content while open.\r\n * - Adds the appropriate ARIA roles are automatically.\r\n * - Easily pluggable animations via a `<Transition/>` component.\r\n *\r\n * Note that, in the same way the backdrop element prevents users from clicking or interacting\r\n * with the page content underneath the Modal, Screen readers also need to be signaled to not to\r\n * interact with page content while the Modal is open. To do this, we use a common technique of applying\r\n * the `aria-hidden='true'` attribute to the non-Modal elements in the Modal `container`. This means that for\r\n * a Modal to be truly modal, it should have a `container` that is _outside_ your app's\r\n * React hierarchy (such as the default: document.body).\r\n */\n\nvar Modal = /*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Modal, _React$Component);\n  function Modal() {\n    var _this;\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = {\n      exited: !_this.props.show\n    };\n    _this.onPortalRendered = function () {\n      if (_this.props.onShow) {\n        _this.props.onShow();\n      } // autofocus after onShow, to not trigger a focus event for previous\n      // modals before this one is shown.\n\n      _this.autoFocus();\n    };\n    _this.onShow = function () {\n      var doc = (0, _ownerDocument.default)(_assertThisInitialized(_assertThisInitialized(_this)));\n      var container = (0, _getContainer.default)(_this.props.container, doc.body);\n      _this.props.manager.add(_assertThisInitialized(_assertThisInitialized(_this)), container, _this.props.containerClassName);\n      _this.removeKeydownListener = (0, _listen.default)(doc, 'keydown', _this.handleDocumentKeyDown);\n      _this.removeFocusListener = (0, _listen.default)(doc, 'focus',\n      // the timeout is necessary b/c this will run before the new modal is mounted\n      // and so steals focus from it\n      function () {\n        return setTimeout(_this.enforceFocus);\n      }, true);\n    };\n    _this.onHide = function () {\n      _this.props.manager.remove(_assertThisInitialized(_assertThisInitialized(_this)));\n      _this.removeKeydownListener();\n      _this.removeFocusListener();\n      if (_this.props.restoreFocus) {\n        _this.restoreLastFocus();\n      }\n    };\n    _this.setDialogRef = function (ref) {\n      _this.dialog = ref;\n    };\n    _this.setBackdropRef = function (ref) {\n      _this.backdrop = ref && _reactDom.default.findDOMNode(ref);\n    };\n    _this.handleHidden = function () {\n      _this.setState({\n        exited: true\n      });\n      _this.onHide();\n      if (_this.props.onExited) {\n        var _this$props;\n        (_this$props = _this.props).onExited.apply(_this$props, arguments);\n      }\n    };\n    _this.handleBackdropClick = function (e) {\n      if (e.target !== e.currentTarget) {\n        return;\n      }\n      if (_this.props.onBackdropClick) {\n        _this.props.onBackdropClick(e);\n      }\n      if (_this.props.backdrop === true) {\n        _this.props.onHide();\n      }\n    };\n    _this.handleDocumentKeyDown = function (e) {\n      if (_this.props.keyboard && e.keyCode === 27 && _this.isTopModal()) {\n        if (_this.props.onEscapeKeyDown) {\n          _this.props.onEscapeKeyDown(e);\n        }\n        _this.props.onHide();\n      }\n    };\n    _this.enforceFocus = function () {\n      if (!_this.props.enforceFocus || !_this._isMounted || !_this.isTopModal()) {\n        return;\n      }\n      var currentActiveElement = (0, _activeElement.default)((0, _ownerDocument.default)(_assertThisInitialized(_assertThisInitialized(_this))));\n      if (_this.dialog && !(0, _contains.default)(_this.dialog, currentActiveElement)) {\n        _this.dialog.focus();\n      }\n    };\n    _this.renderBackdrop = function () {\n      var _this$props2 = _this.props,\n        renderBackdrop = _this$props2.renderBackdrop,\n        Transition = _this$props2.backdropTransition;\n      var backdrop = renderBackdrop({\n        ref: _this.setBackdropRef,\n        onClick: _this.handleBackdropClick\n      });\n      if (Transition) {\n        backdrop = _react.default.createElement(Transition, {\n          appear: true,\n          in: _this.props.show\n        }, backdrop);\n      }\n      return backdrop;\n    };\n    return _this;\n  }\n  Modal.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps) {\n    if (nextProps.show) {\n      return {\n        exited: false\n      };\n    } else if (!nextProps.transition) {\n      // Otherwise let handleHidden take care of marking exited.\n      return {\n        exited: true\n      };\n    }\n    return null;\n  };\n  var _proto = Modal.prototype;\n  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(prevProps) {\n    if (_inDOM.default && !prevProps.show && this.props.show) {\n      this.lastFocus = (0, _activeElement.default)();\n    }\n    return null;\n  };\n  _proto.componentDidMount = function componentDidMount() {\n    this._isMounted = true;\n    if (this.props.show) {\n      this.onShow();\n    }\n  };\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var transition = this.props.transition;\n    if (prevProps.show && !this.props.show && !transition) {\n      // Otherwise handleHidden will call this.\n      this.onHide();\n    } else if (!prevProps.show && this.props.show) {\n      this.onShow();\n    }\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    var _this$props3 = this.props,\n      show = _this$props3.show,\n      transition = _this$props3.transition;\n    this._isMounted = false;\n    if (show || transition && !this.state.exited) {\n      this.onHide();\n    }\n  };\n  _proto.autoFocus = function autoFocus() {\n    if (!this.props.autoFocus) return;\n    var currentActiveElement = (0, _activeElement.default)((0, _ownerDocument.default)(this));\n    if (this.dialog && !(0, _contains.default)(this.dialog, currentActiveElement)) {\n      this.lastFocus = currentActiveElement;\n      this.dialog.focus();\n    }\n  };\n  _proto.restoreLastFocus = function restoreLastFocus() {\n    // Support: <=IE11 doesn't support `focus()` on svg elements (RB: #917)\n    if (this.lastFocus && this.lastFocus.focus) {\n      this.lastFocus.focus();\n      this.lastFocus = null;\n    }\n  };\n  _proto.isTopModal = function isTopModal() {\n    return this.props.manager.isTopModal(this);\n  };\n  _proto.render = function render() {\n    var _this$props4 = this.props,\n      show = _this$props4.show,\n      container = _this$props4.container,\n      children = _this$props4.children,\n      renderDialog = _this$props4.renderDialog,\n      _this$props4$role = _this$props4.role,\n      role = _this$props4$role === void 0 ? 'dialog' : _this$props4$role,\n      Transition = _this$props4.transition,\n      backdrop = _this$props4.backdrop,\n      className = _this$props4.className,\n      style = _this$props4.style,\n      onExit = _this$props4.onExit,\n      onExiting = _this$props4.onExiting,\n      onEnter = _this$props4.onEnter,\n      onEntering = _this$props4.onEntering,\n      onEntered = _this$props4.onEntered,\n      props = _objectWithoutPropertiesLoose(_this$props4, [\"show\", \"container\", \"children\", \"renderDialog\", \"role\", \"transition\", \"backdrop\", \"className\", \"style\", \"onExit\", \"onExiting\", \"onEnter\", \"onEntering\", \"onEntered\"]);\n    if (!(show || Transition && !this.state.exited)) {\n      return null;\n    }\n    var dialogProps = _extends({\n      role: role,\n      ref: this.setDialogRef,\n      // apparently only works on the dialog role element\n      'aria-modal': role === 'dialog' ? true : undefined\n    }, omitProps(props, Modal.propTypes), {\n      style: style,\n      className: className,\n      tabIndex: '-1'\n    });\n    var dialog = renderDialog ? renderDialog(dialogProps) : _react.default.createElement(\"div\", dialogProps, _react.default.cloneElement(children, {\n      role: 'document'\n    }));\n    if (Transition) {\n      dialog = _react.default.createElement(Transition, {\n        appear: true,\n        unmountOnExit: true,\n        in: show,\n        onExit: onExit,\n        onExiting: onExiting,\n        onExited: this.handleHidden,\n        onEnter: onEnter,\n        onEntering: onEntering,\n        onEntered: onEntered\n      }, dialog);\n    }\n    return _react.default.createElement(_Portal.default, {\n      container: container,\n      onRendered: this.onPortalRendered\n    }, _react.default.createElement(_react.default.Fragment, null, backdrop && this.renderBackdrop(), dialog));\n  };\n  return Modal;\n}(_react.default.Component);\nModal.propTypes = {\n  /**\r\n   * Set the visibility of the Modal\r\n   */\n  show: _propTypes.default.bool,\n  /**\r\n   * A Node, Component instance, or function that returns either. The Modal is appended to it's container element.\r\n   *\r\n   * For the sake of assistive technologies, the container should usually be the document body, so that the rest of the\r\n   * page content can be placed behind a virtual backdrop as well as a visual one.\r\n   */\n  container: _propTypes.default.oneOfType([_componentOrElement.default, _propTypes.default.func]),\n  /**\r\n   * A callback fired when the Modal is opening.\r\n   */\n  onShow: _propTypes.default.func,\n  /**\r\n   * A callback fired when either the backdrop is clicked, or the escape key is pressed.\r\n   *\r\n   * The `onHide` callback only signals intent from the Modal,\r\n   * you must actually set the `show` prop to `false` for the Modal to close.\r\n   */\n  onHide: _propTypes.default.func,\n  /**\r\n   * Include a backdrop component.\r\n   */\n  backdrop: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.oneOf(['static'])]),\n  /**\r\n   * A function that returns the dialog component. Useful for custom\r\n   * rendering. **Note:** the component should make sure to apply the provided ref.\r\n   *\r\n   * ```js\r\n   *  renderDialog={props => <MyDialog {...props} />}\r\n   * ```\r\n   */\n  renderDialog: _propTypes.default.func,\n  /**\r\n   * A function that returns a backdrop component. Useful for custom\r\n   * backdrop rendering.\r\n   *\r\n   * ```js\r\n   *  renderBackdrop={props => <MyBackdrop {...props} />}\r\n   * ```\r\n   */\n  renderBackdrop: _propTypes.default.func,\n  /**\r\n   * A callback fired when the escape key, if specified in `keyboard`, is pressed.\r\n   */\n  onEscapeKeyDown: _propTypes.default.func,\n  /**\r\n   * A callback fired when the backdrop, if specified, is clicked.\r\n   */\n  onBackdropClick: _propTypes.default.func,\n  /**\r\n   * A css class or set of classes applied to the modal container when the modal is open,\r\n   * and removed when it is closed.\r\n   */\n  containerClassName: _propTypes.default.string,\n  /**\r\n   * Close the modal when escape key is pressed\r\n   */\n  keyboard: _propTypes.default.bool,\n  /**\r\n   * A `react-transition-group@2.0.0` `<Transition/>` component used\r\n   * to control animations for the dialog component.\r\n   */\n  transition: _elementType.default,\n  /**\r\n   * A `react-transition-group@2.0.0` `<Transition/>` component used\r\n   * to control animations for the backdrop components.\r\n   */\n  backdropTransition: _elementType.default,\n  /**\r\n   * When `true` The modal will automatically shift focus to itself when it opens, and\r\n   * replace it to the last focused element when it closes. This also\r\n   * works correctly with any Modal children that have the `autoFocus` prop.\r\n   *\r\n   * Generally this should never be set to `false` as it makes the Modal less\r\n   * accessible to assistive technologies, like screen readers.\r\n   */\n  autoFocus: _propTypes.default.bool,\n  /**\r\n   * When `true` The modal will prevent focus from leaving the Modal while open.\r\n   *\r\n   * Generally this should never be set to `false` as it makes the Modal less\r\n   * accessible to assistive technologies, like screen readers.\r\n   */\n  enforceFocus: _propTypes.default.bool,\n  /**\r\n   * When `true` The modal will restore focus to previously focused element once\r\n   * modal is hidden\r\n   */\n  restoreFocus: _propTypes.default.bool,\n  /**\r\n   * Callback fired before the Modal transitions in\r\n   */\n  onEnter: _propTypes.default.func,\n  /**\r\n   * Callback fired as the Modal begins to transition in\r\n   */\n  onEntering: _propTypes.default.func,\n  /**\r\n   * Callback fired after the Modal finishes transitioning in\r\n   */\n  onEntered: _propTypes.default.func,\n  /**\r\n   * Callback fired right before the Modal transitions out\r\n   */\n  onExit: _propTypes.default.func,\n  /**\r\n   * Callback fired as the Modal begins to transition out\r\n   */\n  onExiting: _propTypes.default.func,\n  /**\r\n   * Callback fired after the Modal finishes transitioning out\r\n   */\n  onExited: _propTypes.default.func,\n  /**\r\n   * A ModalManager instance used to track and manage the state of open\r\n   * Modals. Useful when customizing how modals interact within a container\r\n   */\n  manager: _propTypes.default.object.isRequired\n};\nModal.defaultProps = {\n  show: false,\n  role: 'dialog',\n  backdrop: true,\n  keyboard: true,\n  autoFocus: true,\n  enforceFocus: true,\n  restoreFocus: true,\n  onHide: function onHide() {},\n  manager: modalManager,\n  renderBackdrop: function renderBackdrop(props) {\n    return _react.default.createElement(\"div\", props);\n  }\n};\nModal.Manager = _ModalManager.default;\nvar _default = Modal;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}