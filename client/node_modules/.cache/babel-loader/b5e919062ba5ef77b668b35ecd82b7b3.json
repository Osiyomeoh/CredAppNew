{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n'use strict';\n\nvar _asyncToGenerator = require(\"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\nvar EthersTransactionUtils = require('@ethersproject/transactions');\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n\n  this.requestManager = options.requestManager;\n\n  // reference to eth.accounts\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n  this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n  this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n  this.defaultCommon = options.defaultCommon;\n  this.defaultChain = options.defaultChain;\n  this.defaultHardfork = options.defaultHardfork;\n  this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager;\n\n  // reference to eth.accounts\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n  if (!this.inputFormatter) {\n    return args;\n  }\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n  return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n    promiseResolved = false,\n    canUnsubscribe = true,\n    timeoutCount = 0,\n    confirmationCount = 0,\n    intervalId = null,\n    lastBlock = null,\n    receiptJSON = '',\n    gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n    isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to,\n    hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n\n  // add custom send Methods\n  var _ethereumCalls = [new Method({\n    name: 'getBlockByNumber',\n    call: 'eth_getBlockByNumber',\n    params: 2,\n    inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n      return !!val;\n    }],\n    outputFormatter: formatters.outputBlockFormatter\n  }), new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Method({\n    name: 'getTransactionByHash',\n    call: 'eth_getTransactionByHash',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionFormatter\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })];\n  // attach methods to this._ethereumCall\n  var _ethereumCall = {};\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  });\n\n  // fire \"receipt\" and confirmation events and resolve after\n  var checkConfirmation = function checkConfirmation(existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function unsubscribe() {\n            clearInterval(intervalId);\n          }\n        };\n      }\n      // if we have a valid receipt we don't need to send a request\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)\n      // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      })\n      // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(receipt) {\n          var block, latestBlock, latestBlockHash;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!receipt || !receipt.blockHash)) {\n                  _context.next = 2;\n                  break;\n                }\n                throw new Error('Receipt missing or blockHash null');\n              case 2:\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                  receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n\n                // check if confirmation listener exists\n                if (!(defer.eventEmitter.listeners('confirmation').length > 0)) {\n                  _context.next = 28;\n                  break;\n                }\n                if (!(existingReceipt === undefined || confirmationCount !== 0)) {\n                  _context.next = 25;\n                  break;\n                }\n                _context.next = 7;\n                return _ethereumCall.getBlockByNumber('latest');\n              case 7:\n                latestBlock = _context.sent;\n                latestBlockHash = latestBlock ? latestBlock.hash : null;\n                if (!isPolling) {\n                  _context.next = 24;\n                  break;\n                }\n                if (!lastBlock) {\n                  _context.next = 17;\n                  break;\n                }\n                _context.next = 13;\n                return _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n              case 13:\n                block = _context.sent;\n                if (block) {\n                  lastBlock = block;\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                }\n                _context.next = 22;\n                break;\n              case 17:\n                _context.next = 19;\n                return _ethereumCall.getBlockByNumber(receipt.blockNumber);\n              case 19:\n                block = _context.sent;\n                lastBlock = block;\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n              case 22:\n                _context.next = 25;\n                break;\n              case 24:\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n              case 25:\n                if (isPolling && block || !isPolling) {\n                  confirmationCount++;\n                }\n                canUnsubscribe = false;\n                if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n                  // add 1 so we account for conf 0\n                  sub.unsubscribe();\n                  defer.eventEmitter.removeAllListeners();\n                }\n              case 28:\n                return _context.abrupt(\"return\", receipt);\n              case 29:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }())\n      // CHECK for CONTRACT DEPLOYMENT\n      .then( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(receipt) {\n          var code, deploymentSuccess;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(isContractDeployment && !promiseResolved)) {\n                  _context2.next = 19;\n                  break;\n                }\n                if (receipt.contractAddress) {\n                  _context2.next = 5;\n                  break;\n                }\n                if (canUnsubscribe) {\n                  sub.unsubscribe();\n                  promiseResolved = true;\n                }\n                utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                return _context2.abrupt(\"return\");\n              case 5:\n                _context2.prev = 5;\n                _context2.next = 8;\n                return _ethereumCall.getCode(receipt.contractAddress);\n              case 8:\n                code = _context2.sent;\n                _context2.next = 13;\n                break;\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](5);\n              case 13:\n                if (code) {\n                  _context2.next = 15;\n                  break;\n                }\n                return _context2.abrupt(\"return\");\n              case 15:\n                // If deployment is status.true and there was a real\n                // bytecode string, assume it was successful.\n                deploymentSuccess = receipt.status === true && hasBytecode;\n                if (deploymentSuccess || code.length > 2) {\n                  defer.eventEmitter.emit('receipt', receipt);\n\n                  // if contract, return instance instead of receipt\n                  if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                    defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                  } else {\n                    defer.resolve(receipt);\n                  }\n\n                  // need to remove listeners, as they aren't removed automatically when succesfull\n                  if (canUnsubscribe) {\n                    defer.eventEmitter.removeAllListeners();\n                  }\n                } else {\n                  utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                }\n                if (canUnsubscribe) {\n                  sub.unsubscribe();\n                }\n                promiseResolved = true;\n              case 19:\n                return _context2.abrupt(\"return\", receipt);\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2, null, [[5, 11]]);\n        }));\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }())\n      // CHECK for normal tx check for receipt only\n      .then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(receipt) {\n          var revertMessage, txReplayOptions, rawTransactionHex, parsedTx;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!isContractDeployment && !promiseResolved)) {\n                  _context3.next = 35;\n                  break;\n                }\n                if (!(!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined'))) {\n                  _context3.next = 7;\n                  break;\n                }\n                defer.eventEmitter.emit('receipt', receipt);\n                defer.resolve(receipt);\n\n                // need to remove listeners, as they aren't removed automatically when succesfull\n                if (canUnsubscribe) {\n                  defer.eventEmitter.removeAllListeners();\n                }\n                _context3.next = 33;\n                break;\n              case 7:\n                receiptJSON = JSON.stringify(receipt, null, 2);\n                if (!(receipt.status === false || receipt.status === '0x0')) {\n                  _context3.next = 32;\n                  break;\n                }\n                _context3.prev = 9;\n                revertMessage = null;\n                if (!(method.handleRevert && (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'))) {\n                  _context3.next = 24;\n                  break;\n                }\n                txReplayOptions = payload.params[0]; // If send was raw, fetch the transaction and reconstitute the\n                // original params so they can be replayed with `eth_call`\n                if (method.call === 'eth_sendRawTransaction') {\n                  rawTransactionHex = payload.params[0];\n                  parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                  txReplayOptions = formatters.inputTransactionFormatter({\n                    data: parsedTx.data,\n                    to: parsedTx.to,\n                    from: parsedTx.from,\n                    gas: parsedTx.gasLimit.toHexString(),\n                    gasPrice: parsedTx.gasPrice.toHexString(),\n                    value: parsedTx.value.toHexString()\n                  });\n                }\n\n                // Get revert reason string with eth_call\n                _context3.next = 16;\n                return method.getRevertReason(txReplayOptions, receipt.blockNumber);\n              case 16:\n                revertMessage = _context3.sent;\n                if (!revertMessage) {\n                  _context3.next = 21;\n                  break;\n                }\n                // Only throw a revert error if a revert reason is existing\n                utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                _context3.next = 22;\n                break;\n              case 21:\n                throw false;\n              case 22:\n                _context3.next = 25;\n                break;\n              case 24:\n                throw false;\n              case 25:\n                _context3.next = 30;\n                break;\n              case 27:\n                _context3.prev = 27;\n                _context3.t0 = _context3[\"catch\"](9);\n                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              case 30:\n                _context3.next = 33;\n                break;\n              case 32:\n                // Throw OOG if status is not existing and provided gas and used gas are equal\n                utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              case 33:\n                if (canUnsubscribe) {\n                  sub.unsubscribe();\n                }\n                promiseResolved = true;\n              case 35:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3, null, [[9, 27]]);\n        }));\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }())\n      // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++;\n\n        // check to see if we are http polling\n        if (!!isPolling) {\n          // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n          if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  };\n\n  // start watching for confirmation depending on the support features of the provider\n  var startWatching = function (existingReceipt) {\n    var startInterval = function startInterval() {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    };\n    if (!this.requestManager.provider.on) {\n      startInterval();\n    } else {\n      _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n        if (err || !blockHeader) {\n          // fall back to polling\n          startInterval();\n        } else {\n          checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        }\n      });\n    }\n  }.bind(this);\n\n  // first check if we already have a confirmed transaction\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\nvar getWallet = function getWallet(from, accounts) {\n  var wallet = null;\n\n  // is index given\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from];\n\n    // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from;\n\n    // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n  return wallet;\n};\nMethod.prototype.buildCall = function () {\n  var method = this,\n    isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction',\n    // || method.call === 'personal_sendTransaction'\n    isCall = method.call === 'eth_call';\n\n  // actual send function\n  var send = function send() {\n    var defer = promiEvent(!isSendTx),\n      payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n    // CALLBACK function\n    var sendTxCallback = function sendTxCallback(err, result) {\n      if (method.handleRevert && isCall && method.abiCoder) {\n        var reasonData;\n\n        // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n        // Geth >= 1.9.15 attaches the reason data to an error object.\n        // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n        if (!err && method.isRevertReasonString(result)) {\n          reasonData = result.substring(10);\n        } else if (err && err.data) {\n          reasonData = err.data.substring(10);\n        }\n        if (reasonData) {\n          var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n          var signature = 'Error(String)';\n          utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n            reason: reason,\n            signature: signature\n          });\n          return;\n        }\n      }\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n      if (result instanceof Error) {\n        err = result;\n      }\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      }\n\n      // return PROMISE\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        }\n\n        // return PROMIEVENT\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n        method._confirmTransaction(defer, result, payload);\n      }\n    };\n\n    // SENDS the SIGNED SIGNATURE\n    var sendSignedTx = function sendSignedTx(sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n    var sendRequest = function sendRequest(payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet;\n\n        // ETH_SENDTRANSACTION\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts);\n\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var txOptions = _.omit(tx, 'from');\n            if (method.defaultChain && !txOptions.chain) {\n              txOptions.chain = method.defaultChain;\n            }\n            if (method.defaultHardfork && !txOptions.hardfork) {\n              txOptions.hardfork = method.defaultHardfork;\n            }\n            if (method.defaultCommon && !txOptions.common) {\n              txOptions.common = method.defaultCommon;\n            }\n            return method.accounts.signTransaction(txOptions, wallet.privateKey).then(sendSignedTx).catch(function (err) {\n              if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                defer.eventEmitter.emit('error', err);\n                defer.eventEmitter.removeAllListeners();\n                defer.eventEmitter.catch(function () {});\n              }\n              defer.reject(err);\n            });\n          }\n\n          // ETH_SIGN\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts);\n\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n      return method.requestManager.send(payload, sendTxCallback);\n    };\n\n    // Send the actual transaction\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n        if (isSendTx) {\n          setTimeout(function () {\n            defer.eventEmitter.emit('sending', payload);\n          }, 0);\n        }\n        sendRequest(payload, method);\n      });\n    } else {\n      if (isSendTx) {\n        setTimeout(function () {\n          defer.eventEmitter.emit('sending', payload);\n        }, 0);\n      }\n      sendRequest(payload, method);\n    }\n    if (isSendTx) {\n      setTimeout(function () {\n        defer.eventEmitter.emit('sent', payload);\n      }, 0);\n    }\n    return defer.eventEmitter;\n  };\n\n  // necessary to attach things to the method\n  send.method = method;\n  // necessary for batch requests\n  send.request = this.request.bind(this);\n  return send;\n};\n\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    new Method({\n      name: 'call',\n      call: 'eth_call',\n      params: 2,\n      abiCoder: self.abiCoder,\n      handleRevert: true\n    }).createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function () {\n      resolve(false);\n    }).catch(function (error) {\n      if (error.reason) {\n        resolve({\n          reason: error.reason,\n          signature: error.signature\n        });\n      } else {\n        reject(error);\n      }\n    });\n  });\n};\n\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n  return _.isString(data) && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\nmodule.exports = Method;","map":null,"metadata":{},"sourceType":"script"}