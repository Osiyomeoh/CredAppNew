{"ast":null,"code":"/*\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\n/**\r\n * @file subscription.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2017\r\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\nvar formatters = require('web3-core-helpers').formatters;\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = _.identity;\n  this.arguments = null;\n  this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n}\n\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n\n/**\r\n * Should be used to extract callback from array of arguments. Modifies input param\r\n *\r\n * @method extractCallback\r\n * @param {Array} arguments\r\n * @return {Function|Null} callback, if exists\r\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n\n/**\r\n * Should be called to check if the number of arguments is correct\r\n *\r\n * @method validateArgs\r\n * @param {Array} arguments\r\n * @throws {Error} if it is not\r\n */\n\nSubscription.prototype._validateArgs = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) subscription = {};\n  if (!subscription.params) subscription.params = 0;\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n  }\n};\n\n/**\r\n * Should be called to format input args of method\r\n *\r\n * @method formatInput\r\n * @param {Array}\r\n * @return {Array}\r\n */\n\nSubscription.prototype._formatInput = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) {\n    return args;\n  }\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n  var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n\n/**\r\n * Should be called to format output(result) of method\r\n *\r\n * @method formatOutput\r\n * @param result {Object}\r\n * @return {Object}\r\n */\n\nSubscription.prototype._formatOutput = function (result) {\n  var subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n\n/**\r\n * Should create payload from given input args\r\n *\r\n * @method toPayload\r\n * @param {Array} args\r\n * @return {Object}\r\n */\nSubscription.prototype._toPayload = function (args) {\n  var params = [];\n  this.callback = this._extractCallback(args) || _.identity;\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift();\n\n    // replace subscription with given name\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n    this._validateArgs(this.arguments);\n    args = []; // make empty after validation\n  }\n\n  // re-add subscriptionName\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n  return {\n    method: this.options.type + '_subscribe',\n    params: params\n  };\n};\n\n/**\r\n * Unsubscribes and clears callbacks\r\n *\r\n * @method unsubscribe\r\n * @return {Object}\r\n */\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.lastBlock = null;\n  this.removeAllListeners();\n};\n\n/**\r\n * Subscribes and watches for changes\r\n *\r\n * @method subscribe\r\n * @param {String} subscription the subscription\r\n * @param {Object} options the options object with address topics and fromBlock\r\n * @return {Object}\r\n */\nSubscription.prototype.subscribe = function () {\n  var _this = this;\n  var args = Array.prototype.slice.call(arguments);\n  var payload = this._toPayload(args);\n  if (!payload) {\n    return this;\n  }\n\n  // throw error, if provider is not set\n  if (!this.options.requestManager.provider) {\n    setTimeout(function () {\n      var err1 = new Error('No provider set.');\n      _this.callback(err1, null, _this);\n      _this.emit('error', err1);\n    }, 0);\n    return this;\n  }\n\n  // throw error, if provider doesnt support subscriptions\n  if (!this.options.requestManager.provider.on) {\n    setTimeout(function () {\n      var err2 = new Error('The current provider doesn\\'t support subscriptions: ' + _this.options.requestManager.provider.constructor.name);\n      _this.callback(err2, null, _this);\n      _this.emit('error', err2);\n    }, 0);\n    return this;\n  }\n\n  // Re-subscription only: continue fetching from the last block we received.\n  // a dropped connection may have resulted in gaps in the logs...\n  if (this.lastBlock && _.isObject(this.options.params)) {\n    payload.params[1] = this.options.params;\n    payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n  }\n\n  // if id is there unsubscribe first\n  if (this.id) {\n    this.unsubscribe();\n  }\n\n  // store the params in the options object\n  this.options.params = payload.params[1];\n\n  // get past logs, if fromBlock is available\n  if (payload.params[0] === 'logs' && _.isObject(payload.params[1]) && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n\n    // copy the params to avoid race-condition with deletion below this block\n    var blockParams = Object.assign({}, payload.params[1]);\n    this.options.requestManager.send({\n      method: 'eth_getLogs',\n      params: [blockParams]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          var output = _this._formatOutput(log);\n          _this.callback(null, output, _this);\n          _this.emit('data', output);\n        });\n\n        // TODO subscribe here? after the past logs?\n      } else {\n        setTimeout(function () {\n          _this.callback(err, null, _this);\n          _this.emit('error', err);\n        }, 0);\n      }\n    });\n  }\n\n  // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n  if (typeof payload.params[1] === 'object') delete payload.params[1].fromBlock;\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n      _this.method = payload.params[0];\n      _this.emit('connected', result);\n\n      // call callback on notifications\n      _this.options.requestManager.addSubscription(_this, function (error, result) {\n        if (!error) {\n          if (!_.isArray(result)) {\n            result = [result];\n          }\n          result.forEach(function (resultItem) {\n            var output = _this._formatOutput(resultItem);\n\n            // Track current block (for gaps introduced by dropped connections)\n            _this.lastBlock = _.isObject(output) ? output.blockNumber : null;\n            if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            } else {\n              _this.emit('data', output);\n            }\n\n            // call the callback, last so that unsubscribe there won't affect the emit above\n            _this.callback(null, output, _this);\n          });\n        } else {\n          _this.callback(error, false, _this);\n          _this.emit('error', error);\n        }\n      });\n    } else {\n      setTimeout(function () {\n        _this.callback(err, false, _this);\n        _this.emit('error', err);\n      }, 0);\n    }\n  });\n\n  // return an object to cancel the subscription\n  return this;\n};\n\n/**\r\n * Resubscribe\r\n *\r\n * @method resubscribe\r\n *\r\n * @returns {void}\r\n */\nSubscription.prototype.resubscribe = function () {\n  this.options.requestManager.removeSubscription(this.id); // unsubscribe\n  this.id = null;\n  this.subscribe(this.callback);\n};\nmodule.exports = Subscription;","map":null,"metadata":{},"sourceType":"script"}