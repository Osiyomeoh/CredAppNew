{"ast":null,"code":"/*\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n */\n/**\r\n * @file WebsocketProvider.js\r\n * @authors: Samuel Furter <samuel@ethereum.org>, Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2019\r\n */\n\n'use strict';\n\nvar EventEmitter = require('eventemitter3');\nvar helpers = require('./helpers.js');\nvar errors = require('web3-core-helpers').errors;\nvar Ws = require('websocket').w3cwebsocket;\n\n/**\r\n * @param {string} url\r\n * @param {Object} options\r\n *\r\n * @constructor\r\n */\nvar WebsocketProvider = function WebsocketProvider(url, options) {\n  EventEmitter.call(this);\n  options = options || {};\n  this.url = url;\n  this._customTimeout = options.timeout || 1000 * 15;\n  this.headers = options.headers || {};\n  this.protocol = options.protocol || undefined;\n  this.reconnectOptions = Object.assign({\n    auto: false,\n    delay: 5000,\n    maxAttempts: false,\n    onTimeout: false\n  }, options.reconnect);\n  this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration\n  this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n\n  this.DATA = 'data';\n  this.CLOSE = 'close';\n  this.ERROR = 'error';\n  this.CONNECT = 'connect';\n  this.RECONNECT = 'reconnect';\n  this.connection = null;\n  this.requestQueue = new Map();\n  this.responseQueue = new Map();\n  this.reconnectAttempts = 0;\n  this.reconnecting = false;\n\n  // The w3cwebsocket implementation does not support Basic Auth\n  // username/password in the URL. So generate the basic auth header, and\n  // pass through with any additional headers supplied in constructor\n  var parsedURL = helpers.parseURL(url);\n  if (parsedURL.username && parsedURL.password) {\n    this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.username + ':' + parsedURL.password);\n  }\n\n  // When all node core implementations that do not have the\n  // WHATWG compatible URL parser go out of service this line can be removed.\n  if (parsedURL.auth) {\n    this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.auth);\n  }\n\n  // make property `connected` which will return the current connection status\n  Object.defineProperty(this, 'connected', {\n    get: function get() {\n      return this.connection && this.connection.readyState === this.connection.OPEN;\n    },\n    enumerable: true\n  });\n  this.connect();\n};\n\n// Inherit from EventEmitter\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype);\nWebsocketProvider.prototype.constructor = WebsocketProvider;\n\n/**\r\n * Connects to the configured node\r\n *\r\n * @method connect\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype.connect = function () {\n  this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);\n  this._addSocketListeners();\n};\n\n/**\r\n * Listener for the `data` event of the underlying WebSocket object\r\n *\r\n * @method _onMessage\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype._onMessage = function (e) {\n  var _this = this;\n  this._parseResponse(typeof e.data === 'string' ? e.data : '').forEach(function (result) {\n    if (result.method && result.method.indexOf('_subscription') !== -1) {\n      _this.emit(_this.DATA, result);\n      return;\n    }\n    var id = result.id;\n\n    // get the id which matches the returned id\n    if (Array.isArray(result)) {\n      id = result[0].id;\n    }\n    if (_this.responseQueue.has(id)) {\n      if (_this.responseQueue.get(id).callback !== undefined) {\n        _this.responseQueue.get(id).callback(false, result);\n      }\n      _this.responseQueue.delete(id);\n    }\n  });\n};\n\n/**\r\n * Listener for the `open` event of the underlying WebSocket object\r\n *\r\n * @method _onConnect\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype._onConnect = function () {\n  this.emit(this.CONNECT);\n  this.reconnectAttempts = 0;\n  this.reconnecting = false;\n  if (this.requestQueue.size > 0) {\n    var _this = this;\n    this.requestQueue.forEach(function (request, key) {\n      _this.send(request.payload, request.callback);\n      _this.requestQueue.delete(key);\n    });\n  }\n};\n\n/**\r\n * Listener for the `close` event of the underlying WebSocket object\r\n *\r\n * @method _onClose\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype._onClose = function (event) {\n  var _this = this;\n  if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n    this.reconnect();\n    return;\n  }\n  this.emit(this.CLOSE, event);\n  if (this.requestQueue.size > 0) {\n    this.requestQueue.forEach(function (request, key) {\n      request.callback(errors.ConnectionNotOpenError(event));\n      _this.requestQueue.delete(key);\n    });\n  }\n  if (this.responseQueue.size > 0) {\n    this.responseQueue.forEach(function (request, key) {\n      request.callback(errors.InvalidConnection('on WS', event));\n      _this.responseQueue.delete(key);\n    });\n  }\n  this._removeSocketListeners();\n  this.removeAllListeners();\n};\n\n/**\r\n * Will add the required socket listeners\r\n *\r\n * @method _addSocketListeners\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype._addSocketListeners = function () {\n  this.connection.addEventListener('message', this._onMessage.bind(this));\n  this.connection.addEventListener('open', this._onConnect.bind(this));\n  this.connection.addEventListener('close', this._onClose.bind(this));\n};\n\n/**\r\n * Will remove all socket listeners\r\n *\r\n * @method _removeSocketListeners\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype._removeSocketListeners = function () {\n  this.connection.removeEventListener('message', this._onMessage);\n  this.connection.removeEventListener('open', this._onConnect);\n  this.connection.removeEventListener('close', this._onClose);\n};\n\n/**\r\n * Will parse the response and make an array out of it.\r\n *\r\n * @method _parseResponse\r\n *\r\n * @param {String} data\r\n *\r\n * @returns {Array}\r\n */\nWebsocketProvider.prototype._parseResponse = function (data) {\n  var _this = this,\n    returnValues = [];\n\n  // DE-CHUNKER\n  var dechunkedData = data.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n  .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n  .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n  .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n  .split('|--|');\n  dechunkedData.forEach(function (data) {\n    // prepend the last chunk\n    if (_this.lastChunk) data = _this.lastChunk + data;\n    var result = null;\n    try {\n      result = JSON.parse(data);\n    } catch (e) {\n      _this.lastChunk = data;\n\n      // start timeout to cancel all requests\n      clearTimeout(_this.lastChunkTimeout);\n      _this.lastChunkTimeout = setTimeout(function () {\n        if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n          _this.reconnect();\n          return;\n        }\n        _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));\n        if (_this.requestQueue.size > 0) {\n          _this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionTimeout(_this._customTimeout));\n            _this.requestQueue.delete(key);\n          });\n        }\n      }, _this._customTimeout);\n      return;\n    }\n\n    // cancel timeout and set chunk to null\n    clearTimeout(_this.lastChunkTimeout);\n    _this.lastChunk = null;\n    if (result) returnValues.push(result);\n  });\n  return returnValues;\n};\n\n/**\r\n * Does check if the provider is connecting and will add it to the queue or will send it directly\r\n *\r\n * @method send\r\n *\r\n * @param {Object} payload\r\n * @param {Function} callback\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype.send = function (payload, callback) {\n  var _this = this;\n  var id = payload.id;\n  var request = {\n    payload: payload,\n    callback: callback\n  };\n  if (Array.isArray(payload)) {\n    id = payload[0].id;\n  }\n  if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n    this.requestQueue.set(id, request);\n    return;\n  }\n  if (this.connection.readyState !== this.connection.OPEN) {\n    this.requestQueue.delete(id);\n    this.emit(this.ERROR, errors.ConnectionNotOpenError());\n    request.callback(errors.ConnectionNotOpenError());\n    return;\n  }\n  this.responseQueue.set(id, request);\n  this.requestQueue.delete(id);\n  try {\n    this.connection.send(JSON.stringify(request.payload));\n  } catch (error) {\n    request.callback(error);\n    _this.responseQueue.delete(id);\n  }\n};\n\n/**\r\n * Resets the providers, clears all callbacks\r\n *\r\n * @method reset\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype.reset = function () {\n  this.responseQueue.clear();\n  this.requestQueue.clear();\n  this.removeAllListeners();\n  this._removeSocketListeners();\n  this._addSocketListeners();\n};\n\n/**\r\n * Closes the current connection with the given code and reason arguments\r\n *\r\n * @method disconnect\r\n *\r\n * @param {number} code\r\n * @param {string} reason\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype.disconnect = function (code, reason) {\n  this._removeSocketListeners();\n  this.connection.close(code || 1000, reason);\n};\n\n/**\r\n * Returns the desired boolean.\r\n *\r\n * @method supportsSubscriptions\r\n *\r\n * @returns {boolean}\r\n */\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n  return true;\n};\n\n/**\r\n * Removes the listeners and reconnects to the socket.\r\n *\r\n * @method reconnect\r\n *\r\n * @returns {void}\r\n */\nWebsocketProvider.prototype.reconnect = function () {\n  var _this = this;\n  this.reconnecting = true;\n  if (this.responseQueue.size > 0) {\n    this.responseQueue.forEach(function (request, key) {\n      request.callback(errors.PendingRequestsOnReconnectingError());\n      _this.responseQueue.delete(key);\n    });\n  }\n  if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n    setTimeout(function () {\n      _this.reconnectAttempts++;\n      _this._removeSocketListeners();\n      _this.emit(_this.RECONNECT, _this.reconnectAttempts);\n      _this.connect();\n    }, this.reconnectOptions.delay);\n    return;\n  }\n  this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());\n  this.reconnecting = false;\n  if (this.requestQueue.size > 0) {\n    this.requestQueue.forEach(function (request, key) {\n      request.callback(errors.MaxAttemptsReachedOnReconnectingError());\n      _this.requestQueue.delete(key);\n    });\n  }\n};\nmodule.exports = WebsocketProvider;","map":null,"metadata":{},"sourceType":"script"}