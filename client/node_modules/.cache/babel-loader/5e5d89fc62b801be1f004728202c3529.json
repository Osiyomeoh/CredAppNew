{"ast":null,"code":"\"use strict\";\n\nimport _get from \"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _classCallCheck from \"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\CredApp\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nvar errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n  if (value == null) {\n    return null;\n  }\n  // These *are* the droids we're looking for.\n  if (typeof value.message === \"string\" && value.message.match(\"reverted\")) {\n    var data = isHexString(value.data) ? value.data : null;\n    if (!requireData || data) {\n      return {\n        message: value.message,\n        data: data\n      };\n    }\n  }\n  // Spelunk further...\n  if (typeof value === \"object\") {\n    for (var key in value) {\n      var result = spelunk(value[key], requireData);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n  // Might be a JSON string we can further descend...\n  if (typeof value === \"string\") {\n    try {\n      return spelunk(JSON.parse(value), requireData);\n    } catch (error) {}\n  }\n  return null;\n}\nfunction checkError(method, error, params) {\n  var transaction = params.transaction || params.signedTransaction;\n  // Undo the \"convenience\" some nodes are attempting to prevent backwards\n  // incompatibility; maybe for v6 consider forwarding reverts as errors\n  if (method === \"call\") {\n    var result = spelunk(error, true);\n    if (result) {\n      return result.data;\n    }\n    // Nothing descriptive..\n    logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n      data: \"0x\",\n      transaction: transaction,\n      error: error\n    });\n  }\n  if (method === \"estimateGas\") {\n    // Try to find something, with a preference on SERVER_ERROR body\n    var _result = spelunk(error.body, false);\n    if (_result == null) {\n      _result = spelunk(error, false);\n    }\n    // Found \"reverted\", this is a CALL_EXCEPTION\n    if (_result) {\n      logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n        reason: _result.message,\n        method: method,\n        transaction: transaction,\n        error: error\n      });\n    }\n  }\n  // @TODO: Should we spelunk for message too?\n  var message = error.message;\n  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === \"string\") {\n    message = error.error.message;\n  } else if (typeof error.body === \"string\") {\n    message = error.body;\n  } else if (typeof error.responseText === \"string\") {\n    message = error.responseText;\n  }\n  message = (message || \"\").toLowerCase();\n  // \"insufficient funds for gas * price + value + cost(data)\"\n  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n    logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n      error: error,\n      method: method,\n      transaction: transaction\n    });\n  }\n  // \"nonce too low\"\n  if (message.match(/nonce (is )?too low/i)) {\n    logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n      error: error,\n      method: method,\n      transaction: transaction\n    });\n  }\n  // \"replacement transaction underpriced\"\n  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n    logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n      error: error,\n      method: method,\n      transaction: transaction\n    });\n  }\n  // \"replacement transaction underpriced\"\n  if (message.match(/only replay-protected/i)) {\n    logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n      error: error,\n      method: method,\n      transaction: transaction\n    });\n  }\n  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n    logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n      error: error,\n      method: method,\n      transaction: transaction\n    });\n  }\n  throw error;\n}\nfunction timer(timeout) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction getResult(payload) {\n  if (payload.error) {\n    // @TODO: not any\n    var error = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n  return payload.result;\n}\nfunction getLowerCase(value) {\n  if (value) {\n    return value.toLowerCase();\n  }\n  return value;\n}\nvar _constructorGuard = {};\nexport var JsonRpcSigner = /*#__PURE__*/function (_Signer) {\n  _inherits(JsonRpcSigner, _Signer);\n  function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {\n    var _this;\n    _classCallCheck(this, JsonRpcSigner);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(JsonRpcSigner).call(this));\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n    }\n    defineReadOnly(_assertThisInitialized(_assertThisInitialized(_this)), \"provider\", provider);\n    if (addressOrIndex == null) {\n      addressOrIndex = 0;\n    }\n    if (typeof addressOrIndex === \"string\") {\n      defineReadOnly(_assertThisInitialized(_assertThisInitialized(_this)), \"_address\", _this.provider.formatter.address(addressOrIndex));\n      defineReadOnly(_assertThisInitialized(_assertThisInitialized(_this)), \"_index\", null);\n    } else if (typeof addressOrIndex === \"number\") {\n      defineReadOnly(_assertThisInitialized(_assertThisInitialized(_this)), \"_index\", addressOrIndex);\n      defineReadOnly(_assertThisInitialized(_assertThisInitialized(_this)), \"_address\", null);\n    } else {\n      logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n    }\n    return _this;\n  }\n  _createClass(JsonRpcSigner, [{\n    key: \"connect\",\n    value: function connect(provider) {\n      return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"connect\"\n      });\n    }\n  }, {\n    key: \"connectUnchecked\",\n    value: function connectUnchecked() {\n      return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      var _this2 = this;\n      if (this._address) {\n        return Promise.resolve(this._address);\n      }\n      return this.provider.send(\"eth_accounts\", []).then(function (accounts) {\n        if (accounts.length <= _this2._index) {\n          logger.throwError(\"unknown account #\" + _this2._index, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getAddress\"\n          });\n        }\n        return _this2.provider.formatter.address(accounts[_this2._index]);\n      });\n    }\n  }, {\n    key: \"sendUncheckedTransaction\",\n    value: function sendUncheckedTransaction(transaction) {\n      var _this3 = this;\n      transaction = shallowCopy(transaction);\n      var fromAddress = this.getAddress().then(function (address) {\n        if (address) {\n          address = address.toLowerCase();\n        }\n        return address;\n      });\n      // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n      // wishes to use this, it is easy to specify explicitly, otherwise\n      // we look it up for them.\n      if (transaction.gasLimit == null) {\n        var estimate = shallowCopy(transaction);\n        estimate.from = fromAddress;\n        transaction.gasLimit = this.provider.estimateGas(estimate);\n      }\n      if (transaction.to != null) {\n        transaction.to = Promise.resolve(transaction.to).then(function (to) {\n          return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            var address;\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  if (!(to == null)) {\n                    _context.next = 2;\n                    break;\n                  }\n                  return _context.abrupt(\"return\", null);\n                case 2:\n                  _context.next = 4;\n                  return this.provider.resolveName(to);\n                case 4:\n                  address = _context.sent;\n                  if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                  }\n                  return _context.abrupt(\"return\", address);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee, this);\n          }));\n        });\n      }\n      return resolveProperties({\n        tx: resolveProperties(transaction),\n        sender: fromAddress\n      }).then(function (_ref) {\n        var tx = _ref.tx,\n          sender = _ref.sender;\n        if (tx.from != null) {\n          if (tx.from.toLowerCase() !== sender) {\n            logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n          }\n        } else {\n          tx.from = sender;\n        }\n        var hexTx = _this3.provider.constructor.hexlifyTransaction(tx, {\n          from: true\n        });\n        return _this3.provider.send(\"eth_sendTransaction\", [hexTx]).then(function (hash) {\n          return hash;\n        }, function (error) {\n          if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n            logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n              action: \"sendTransaction\",\n              transaction: tx\n            });\n          }\n          return checkError(\"sendTransaction\", error, hexTx);\n        });\n      });\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(transaction) {\n      return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"signTransaction\"\n      });\n    }\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this4 = this;\n        var blockNumber, hash;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            case 2:\n              blockNumber = _context3.sent;\n              _context3.next = 5;\n              return this.sendUncheckedTransaction(transaction);\n            case 5:\n              hash = _context3.sent;\n              _context3.prev = 6;\n              _context3.next = 9;\n              return poll(function () {\n                return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                  var tx;\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return this.provider.getTransaction(hash);\n                      case 2:\n                        tx = _context2.sent;\n                        if (!(tx === null)) {\n                          _context2.next = 5;\n                          break;\n                        }\n                        return _context2.abrupt(\"return\", undefined);\n                      case 5:\n                        return _context2.abrupt(\"return\", this.provider._wrapTransaction(tx, hash, blockNumber));\n                      case 6:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2, this);\n                }));\n              }, {\n                oncePoll: this.provider\n              });\n            case 9:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 12:\n              _context3.prev = 12;\n              _context3.t0 = _context3[\"catch\"](6);\n              _context3.t0.transactionHash = hash;\n              throw _context3.t0;\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[6, 12]]);\n      }));\n    }\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var data, address;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              data = typeof message === \"string\" ? toUtf8Bytes(message) : message;\n              _context4.next = 3;\n              return this.getAddress();\n            case 3:\n              address = _context4.sent;\n              _context4.prev = 4;\n              _context4.next = 7;\n              return this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n            case 7:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 10:\n              _context4.prev = 10;\n              _context4.t0 = _context4[\"catch\"](4);\n              if (typeof _context4.t0.message === \"string\" && _context4.t0.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                  action: \"signMessage\",\n                  from: address,\n                  messageData: message\n                });\n              }\n              throw _context4.t0;\n            case 14:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[4, 10]]);\n      }));\n    }\n  }, {\n    key: \"_legacySignMessage\",\n    value: function _legacySignMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var data, address;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              data = typeof message === \"string\" ? toUtf8Bytes(message) : message;\n              _context5.next = 3;\n              return this.getAddress();\n            case 3:\n              address = _context5.sent;\n              _context5.prev = 4;\n              _context5.next = 7;\n              return this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n            case 7:\n              return _context5.abrupt(\"return\", _context5.sent);\n            case 10:\n              _context5.prev = 10;\n              _context5.t0 = _context5[\"catch\"](4);\n              if (typeof _context5.t0.message === \"string\" && _context5.t0.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                  action: \"_legacySignMessage\",\n                  from: address,\n                  messageData: message\n                });\n              }\n              throw _context5.t0;\n            case 14:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[4, 10]]);\n      }));\n    }\n  }, {\n    key: \"_signTypedData\",\n    value: function _signTypedData(domain, types, value) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this5 = this;\n        var populated, address;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return _TypedDataEncoder.resolveNames(domain, types, value, function (name) {\n                return _this5.provider.resolveName(name);\n              });\n            case 2:\n              populated = _context6.sent;\n              _context6.next = 5;\n              return this.getAddress();\n            case 5:\n              address = _context6.sent;\n              _context6.prev = 6;\n              _context6.next = 9;\n              return this.provider.send(\"eth_signTypedData_v4\", [address.toLowerCase(), JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);\n            case 9:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 12:\n              _context6.prev = 12;\n              _context6.t0 = _context6[\"catch\"](6);\n              if (typeof _context6.t0.message === \"string\" && _context6.t0.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                  action: \"_signTypedData\",\n                  from: address,\n                  messageData: {\n                    domain: populated.domain,\n                    types: types,\n                    value: populated.value\n                  }\n                });\n              }\n              throw _context6.t0;\n            case 16:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[6, 12]]);\n      }));\n    }\n  }, {\n    key: \"unlock\",\n    value: function unlock(password) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var provider, address;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              provider = this.provider;\n              _context7.next = 3;\n              return this.getAddress();\n            case 3:\n              address = _context7.sent;\n              return _context7.abrupt(\"return\", provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]));\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n    }\n  }]);\n  return JsonRpcSigner;\n}(Signer);\nvar UncheckedJsonRpcSigner = /*#__PURE__*/function (_JsonRpcSigner) {\n  _inherits(UncheckedJsonRpcSigner, _JsonRpcSigner);\n  function UncheckedJsonRpcSigner() {\n    _classCallCheck(this, UncheckedJsonRpcSigner);\n    return _possibleConstructorReturn(this, _getPrototypeOf(UncheckedJsonRpcSigner).apply(this, arguments));\n  }\n  _createClass(UncheckedJsonRpcSigner, [{\n    key: \"sendTransaction\",\n    value: function sendTransaction(transaction) {\n      var _this6 = this;\n      return this.sendUncheckedTransaction(transaction).then(function (hash) {\n        return {\n          hash: hash,\n          nonce: null,\n          gasLimit: null,\n          gasPrice: null,\n          data: null,\n          value: null,\n          chainId: null,\n          confirmations: 0,\n          from: null,\n          wait: function wait(confirmations) {\n            return _this6.provider.waitForTransaction(hash, confirmations);\n          }\n        };\n      });\n    }\n  }]);\n  return UncheckedJsonRpcSigner;\n}(JsonRpcSigner);\nvar allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true,\n  type: true,\n  accessList: true,\n  maxFeePerGas: true,\n  maxPriorityFeePerGas: true\n};\nexport var JsonRpcProvider = /*#__PURE__*/function (_BaseProvider) {\n  _inherits(JsonRpcProvider, _BaseProvider);\n  function JsonRpcProvider(url, network) {\n    var _this7;\n    _classCallCheck(this, JsonRpcProvider);\n    var networkOrReady = network;\n    // The network is unknown, query the JSON-RPC for it\n    if (networkOrReady == null) {\n      networkOrReady = new Promise(function (resolve, reject) {\n        setTimeout(function () {\n          _this7.detectNetwork().then(function (network) {\n            resolve(network);\n          }, function (error) {\n            reject(error);\n          });\n        }, 0);\n      });\n    }\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(JsonRpcProvider).call(this, networkOrReady));\n    // Default URL\n    if (!url) {\n      url = getStatic(_this7.constructor, \"defaultUrl\")();\n    }\n    if (typeof url === \"string\") {\n      defineReadOnly(_assertThisInitialized(_assertThisInitialized(_this7)), \"connection\", Object.freeze({\n        url: url\n      }));\n    } else {\n      defineReadOnly(_assertThisInitialized(_assertThisInitialized(_this7)), \"connection\", Object.freeze(shallowCopy(url)));\n    }\n    _this7._nextId = 42;\n    return _this7;\n  }\n  _createClass(JsonRpcProvider, [{\n    key: \"detectNetwork\",\n    value: function detectNetwork() {\n      var _this8 = this;\n      if (!this._cache[\"detectNetwork\"]) {\n        this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n        // Clear this cache at the beginning of the next event loop\n        setTimeout(function () {\n          _this8._cache[\"detectNetwork\"] = null;\n        }, 0);\n      }\n      return this._cache[\"detectNetwork\"];\n    }\n  }, {\n    key: \"_uncachedDetectNetwork\",\n    value: function _uncachedDetectNetwork() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var chainId, getNetwork;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return timer(0);\n            case 2:\n              chainId = null;\n              _context8.prev = 3;\n              _context8.next = 6;\n              return this.send(\"eth_chainId\", []);\n            case 6:\n              chainId = _context8.sent;\n              _context8.next = 19;\n              break;\n            case 9:\n              _context8.prev = 9;\n              _context8.t0 = _context8[\"catch\"](3);\n              _context8.prev = 11;\n              _context8.next = 14;\n              return this.send(\"net_version\", []);\n            case 14:\n              chainId = _context8.sent;\n              _context8.next = 19;\n              break;\n            case 17:\n              _context8.prev = 17;\n              _context8.t1 = _context8[\"catch\"](11);\n            case 19:\n              if (!(chainId != null)) {\n                _context8.next = 28;\n                break;\n              }\n              getNetwork = getStatic(this.constructor, \"getNetwork\");\n              _context8.prev = 21;\n              return _context8.abrupt(\"return\", getNetwork(BigNumber.from(chainId).toNumber()));\n            case 25:\n              _context8.prev = 25;\n              _context8.t2 = _context8[\"catch\"](21);\n              return _context8.abrupt(\"return\", logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                chainId: chainId,\n                event: \"invalidNetwork\",\n                serverError: _context8.t2\n              }));\n            case 28:\n              return _context8.abrupt(\"return\", logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n              }));\n            case 29:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[3, 9], [11, 17], [21, 25]]);\n      }));\n    }\n  }, {\n    key: \"getSigner\",\n    value: function getSigner(addressOrIndex) {\n      return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n  }, {\n    key: \"getUncheckedSigner\",\n    value: function getUncheckedSigner(addressOrIndex) {\n      return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n  }, {\n    key: \"listAccounts\",\n    value: function listAccounts() {\n      var _this9 = this;\n      return this.send(\"eth_accounts\", []).then(function (accounts) {\n        return accounts.map(function (a) {\n          return _this9.formatter.address(a);\n        });\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(method, params) {\n      var _this10 = this;\n      var request = {\n        method: method,\n        params: params,\n        id: this._nextId++,\n        jsonrpc: \"2.0\"\n      };\n      this.emit(\"debug\", {\n        action: \"request\",\n        request: deepCopy(request),\n        provider: this\n      });\n      // We can expand this in the future to any call, but for now these\n      // are the biggest wins and do not require any serializing parameters.\n      var cache = [\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0;\n      if (cache && this._cache[method]) {\n        return this._cache[method];\n      }\n      var result = fetchJson(this.connection, JSON.stringify(request), getResult).then(function (result) {\n        _this10.emit(\"debug\", {\n          action: \"response\",\n          request: request,\n          response: result,\n          provider: _this10\n        });\n        return result;\n      }, function (error) {\n        _this10.emit(\"debug\", {\n          action: \"response\",\n          error: error,\n          request: request,\n          provider: _this10\n        });\n        throw error;\n      });\n      // Cache the fetch, but clear it on the next event loop\n      if (cache) {\n        this._cache[method] = result;\n        setTimeout(function () {\n          _this10._cache[method] = null;\n        }, 0);\n      }\n      return result;\n    }\n  }, {\n    key: \"prepareRequest\",\n    value: function prepareRequest(method, params) {\n      switch (method) {\n        case \"getBlockNumber\":\n          return [\"eth_blockNumber\", []];\n        case \"getGasPrice\":\n          return [\"eth_gasPrice\", []];\n        case \"getBalance\":\n          return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n        case \"getTransactionCount\":\n          return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n        case \"getCode\":\n          return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n        case \"getStorageAt\":\n          return [\"eth_getStorageAt\", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];\n        case \"sendTransaction\":\n          return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n        case \"getBlock\":\n          if (params.blockTag) {\n            return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n          } else if (params.blockHash) {\n            return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n          }\n          return null;\n        case \"getTransaction\":\n          return [\"eth_getTransactionByHash\", [params.transactionHash]];\n        case \"getTransactionReceipt\":\n          return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n        case \"call\":\n          {\n            var hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n            return [\"eth_call\", [hexlifyTransaction(params.transaction, {\n              from: true\n            }), params.blockTag]];\n          }\n        case \"estimateGas\":\n          {\n            var _hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n            return [\"eth_estimateGas\", [_hexlifyTransaction(params.transaction, {\n              from: true\n            })]];\n          }\n        case \"getLogs\":\n          if (params.filter && params.filter.address != null) {\n            params.filter.address = getLowerCase(params.filter.address);\n          }\n          return [\"eth_getLogs\", [params.filter]];\n        default:\n          break;\n      }\n      return null;\n    }\n  }, {\n    key: \"perform\",\n    value: function perform(method, params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var tx, feeData, args;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!(method === \"call\" || method === \"estimateGas\")) {\n                _context9.next = 8;\n                break;\n              }\n              tx = params.transaction;\n              if (!(tx && tx.type != null && BigNumber.from(tx.type).isZero())) {\n                _context9.next = 8;\n                break;\n              }\n              if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) {\n                _context9.next = 8;\n                break;\n              }\n              _context9.next = 6;\n              return this.getFeeData();\n            case 6:\n              feeData = _context9.sent;\n              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                // Network doesn't know about EIP-1559 (and hence type)\n                params = shallowCopy(params);\n                params.transaction = shallowCopy(tx);\n                delete params.transaction.type;\n              }\n            case 8:\n              args = this.prepareRequest(method, params);\n              if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, {\n                  operation: method\n                });\n              }\n              _context9.prev = 10;\n              _context9.next = 13;\n              return this.send(args[0], args[1]);\n            case 13:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 16:\n              _context9.prev = 16;\n              _context9.t0 = _context9[\"catch\"](10);\n              return _context9.abrupt(\"return\", checkError(method, _context9.t0, params));\n            case 19:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[10, 16]]);\n      }));\n    }\n  }, {\n    key: \"_startEvent\",\n    value: function _startEvent(event) {\n      if (event.tag === \"pending\") {\n        this._startPending();\n      }\n      _get(_getPrototypeOf(JsonRpcProvider.prototype), \"_startEvent\", this).call(this, event);\n    }\n  }, {\n    key: \"_startPending\",\n    value: function _startPending() {\n      if (this._pendingFilter != null) {\n        return;\n      }\n      var self = this;\n      var pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n      this._pendingFilter = pendingFilter;\n      pendingFilter.then(function (filterId) {\n        function poll() {\n          self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n            if (self._pendingFilter != pendingFilter) {\n              return null;\n            }\n            var seq = Promise.resolve();\n            hashes.forEach(function (hash) {\n              // @TODO: This should be garbage collected at some point... How? When?\n              self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n              seq = seq.then(function () {\n                return self.getTransaction(hash).then(function (tx) {\n                  self.emit(\"pending\", tx);\n                  return null;\n                });\n              });\n            });\n            return seq.then(function () {\n              return timer(1000);\n            });\n          }).then(function () {\n            if (self._pendingFilter != pendingFilter) {\n              self.send(\"eth_uninstallFilter\", [filterId]);\n              return;\n            }\n            setTimeout(function () {\n              poll();\n            }, 0);\n            return null;\n          }).catch(function (error) {});\n        }\n        poll();\n        return filterId;\n      }).catch(function (error) {});\n    }\n  }, {\n    key: \"_stopEvent\",\n    value: function _stopEvent(event) {\n      if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n        this._pendingFilter = null;\n      }\n      _get(_getPrototypeOf(JsonRpcProvider.prototype), \"_stopEvent\", this).call(this, event);\n    } // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n  }, {\n    key: \"_cache\",\n    get: function get() {\n      if (this._eventLoopCache == null) {\n        this._eventLoopCache = {};\n      }\n      return this._eventLoopCache;\n    }\n  }], [{\n    key: \"defaultUrl\",\n    value: function defaultUrl() {\n      return \"http:/\\/localhost:8545\";\n    }\n  }, {\n    key: \"hexlifyTransaction\",\n    value: function hexlifyTransaction(transaction, allowExtra) {\n      // Check only allowed properties are given\n      var allowed = shallowCopy(allowedTransactionKeys);\n      if (allowExtra) {\n        for (var key in allowExtra) {\n          if (allowExtra[key]) {\n            allowed[key] = true;\n          }\n        }\n      }\n      checkProperties(transaction, allowed);\n      var result = {};\n      // JSON-RPC now requires numeric values to be \"quantity\" values\n      [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n        if (transaction[key] == null) {\n          return;\n        }\n        var value = hexValue(BigNumber.from(transaction[key]));\n        if (key === \"gasLimit\") {\n          key = \"gas\";\n        }\n        result[key] = value;\n      });\n      [\"from\", \"to\", \"data\"].forEach(function (key) {\n        if (transaction[key] == null) {\n          return;\n        }\n        result[key] = hexlify(transaction[key]);\n      });\n      if (transaction.accessList) {\n        result[\"accessList\"] = accessListify(transaction.accessList);\n      }\n      return result;\n    }\n  }]);\n  return JsonRpcProvider;\n}(BaseProvider);","map":null,"metadata":{},"sourceType":"module"}