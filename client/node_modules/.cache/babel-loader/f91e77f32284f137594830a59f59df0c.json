{"ast":null,"code":"/**\r\n * Multihash implementation in JavaScript.\r\n *\r\n * @module multihash\r\n */\n'use strict';\n\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar multibase = require('multibase');\nvar varint = require('varint');\nvar cs = require('./constants');\nexports.names = cs.names;\nexports.codes = cs.codes;\nexports.defaultLengths = cs.defaultLengths;\n\n/**\r\n * Convert the given multihash to a hex encoded string.\r\n *\r\n * @param {Buffer} hash\r\n * @returns {string}\r\n */\nexports.toHexString = function toHexString(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n  return hash.toString('hex');\n};\n\n/**\r\n * Convert the given hex encoded string to a multihash.\r\n *\r\n * @param {string} hash\r\n * @returns {Buffer}\r\n */\nexports.fromHexString = function fromHexString(hash) {\n  return Buffer.from(hash, 'hex');\n};\n\n/**\r\n * Convert the given multihash to a base58 encoded string.\r\n *\r\n * @param {Buffer} hash\r\n * @returns {string}\r\n */\nexports.toB58String = function toB58String(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n  return multibase.encode('base58btc', hash).toString().slice(1);\n};\n\n/**\r\n * Convert the given base58 encoded string to a multihash.\r\n *\r\n * @param {string|Buffer} hash\r\n * @returns {Buffer}\r\n */\nexports.fromB58String = function fromB58String(hash) {\n  var encoded = hash;\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString();\n  }\n  return multibase.decode('z' + encoded);\n};\n\n/**\r\n * Decode a hash from the given multihash.\r\n *\r\n * @param {Buffer} buf\r\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\r\n */\nexports.decode = function decode(buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('multihash must be a Buffer');\n  }\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n  var code = varint.decode(buf);\n  if (!exports.isValidCode(code)) {\n    throw new Error(\"multihash unknown function code: 0x\".concat(code.toString(16)));\n  }\n  buf = buf.slice(varint.decode.bytes);\n  var len = varint.decode(buf);\n  if (len < 0) {\n    throw new Error(\"multihash invalid length: \".concat(len));\n  }\n  buf = buf.slice(varint.decode.bytes);\n  if (buf.length !== len) {\n    throw new Error(\"multihash length inconsistent: 0x\".concat(buf.toString('hex')));\n  }\n  return {\n    code: code,\n    name: cs.codes[code],\n    length: len,\n    digest: buf\n  };\n};\n\n/**\r\n *  Encode a hash digest along with the specified function code.\r\n *\r\n * > **Note:** the length is derived from the length of the digest itself.\r\n *\r\n * @param {Buffer} digest\r\n * @param {string|number} code\r\n * @param {number} [length]\r\n * @returns {Buffer}\r\n */\nexports.encode = function encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  }\n\n  // ensure it's a hashfunction code.\n  var hashfn = exports.coerceCode(code);\n  if (!Buffer.isBuffer(digest)) {\n    throw new Error('digest should be a Buffer');\n  }\n  if (length == null) {\n    length = digest.length;\n  }\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n  return Buffer.concat([Buffer.from(varint.encode(hashfn)), Buffer.from(varint.encode(length)), digest]);\n};\n\n/**\r\n * Converts a hash function name into the matching code.\r\n * If passed a number it will return the number if it's a valid code.\r\n * @param {string|number} name\r\n * @returns {number}\r\n */\nexports.coerceCode = function coerceCode(name) {\n  var code = name;\n  if (typeof name === 'string') {\n    if (cs.names[name] === undefined) {\n      throw new Error(\"Unrecognized hash function named: \".concat(name));\n    }\n    code = cs.names[name];\n  }\n  if (typeof code !== 'number') {\n    throw new Error(\"Hash function code should be a number. Got: \".concat(code));\n  }\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(\"Unrecognized function code: \".concat(code));\n  }\n  return code;\n};\n\n/**\r\n * Checks wether a code is part of the app range\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\nexports.isAppCode = function appCode(code) {\n  return code > 0 && code < 0x10;\n};\n\n/**\r\n * Checks whether a multihash code is valid.\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\nexports.isValidCode = function validCode(code) {\n  if (exports.isAppCode(code)) {\n    return true;\n  }\n  if (cs.codes[code]) {\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Buffer} multihash\r\n * @returns {undefined}\r\n * @throws {Error}\r\n */\nfunction validate(multihash) {\n  exports.decode(multihash); // throws if bad.\n}\n\nexports.validate = validate;\n\n/**\r\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Buffer} multihash\r\n * @returns {undefined}\r\n * @throws {Error}\r\n */\nexports.prefix = function prefix(multihash) {\n  validate(multihash);\n  return multihash.slice(0, 2);\n};","map":null,"metadata":{},"sourceType":"script"}