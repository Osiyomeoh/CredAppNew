{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\r\n * Returns a zero address.\r\n */\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\r\n * Checks if the address is a valid. Accepts checksummed addresses too.\r\n */\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\r\n * Checks if a given address is a zero address.\r\n */\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\r\n * Returns a checksummed address.\r\n *\r\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\r\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\r\n * For more details, consult EIP-1191.\r\n *\r\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\r\n * used variation in Ethereum was without the chainId. This may change in the future.\r\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccak(prefix + address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\n/**\r\n * Checks if the address is a valid checksummed address.\r\n *\r\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\r\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\r\n * Generates an address of a newly created contract.\r\n * @param from The address which is creating this new address\r\n * @param nonce The nonce of the from account\r\n */\nexports.generateAddress = function (from, nonce) {\n  from = bytes_1.toBuffer(from);\n  var nonceBN = new BN(nonce);\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\r\n * Generates an address for a contract created using CREATE2.\r\n * @param from The address which is creating this new address\r\n * @param salt A salt\r\n * @param initCode The init code of the contract being created\r\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = bytes_1.toBuffer(from);\n  var saltBuf = bytes_1.toBuffer(salt);\n  var initCodeBuf = bytes_1.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\r\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\r\n */\nexports.isPrecompiled = function (address) {\n  var a = bytes_1.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\r\n * Checks if the private key satisfies the rules of the curve secp256k1.\r\n */\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\r\n * Checks if the public key satisfies the rules of the curve secp256k1\r\n * and the requirements of Ethereum.\r\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\r\n * Returns the ethereum address of a given public key.\r\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\r\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  pubKey = bytes_1.toBuffer(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n  assert(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\r\n * Returns the ethereum address of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\r\n * Returns the ethereum public key of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\nexports.privateToPublic = function (privateKey) {\n  privateKey = bytes_1.toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\r\n * Converts a public key to the Ethereum format.\r\n */\nexports.importPublic = function (publicKey) {\n  publicKey = bytes_1.toBuffer(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n  return publicKey;\n};","map":null,"metadata":{},"sourceType":"script"}