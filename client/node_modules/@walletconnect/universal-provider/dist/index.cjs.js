"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var y=require("pino"),P=require("@walletconnect/sign-client"),v=require("@walletconnect/utils"),N=require("@walletconnect/logger"),h=require("@walletconnect/jsonrpc-provider"),w=require("@walletconnect/jsonrpc-http-connection"),_=require("events");function p(i){return i&&typeof i=="object"&&"default"in i?i:{default:i}}var H=p(y),O=p(P),m=p(w),q=p(_);const C="error",b="wss://relay.walletconnect.com",D="wc",S="universal_provider",I=`${D}@${2}:${S}:`,R="https://rpc.walletconnect.com/v1",o={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function a(i,e,t){let s;const n=f(i);return e.rpcMap&&(s=e.rpcMap[n]),s||(s=`${R}?chainId=eip155:${n}&projectId=${t}`),s}function f(i){return i.includes("eip155")?Number(i.split(":")[1]):Number(i)}function j(i,e){if(!e.includes(i))throw new Error(`Chain '${i}' not approved. Please use one of the following: ${e.toString()}`)}function L(i){return i.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}const d=(i,e)=>{const t=s=>{s.request!==e.request||s.topic!==e.topic||(i.events.removeListener("session_request_sent",t),U())};i.on("session_request_sent",t)};function U(){if(typeof window<"u")try{const i=window.localStorage.getItem("WALLETCONNECT_DEEPLINK_CHOICE");if(i){const e=JSON.parse(i);window.open(e.href,"_self","noreferrer noopener")}}catch(i){console.error(i)}}class k{constructor(e){this.name="eip155",this.namespace=e.namespace,this.client=e.client,this.events=e.events,this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(e){var t;switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return this.handleSwitchChain(e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0"),null;case"eth_chainId":return parseInt(this.getDefaultChain())}return this.namespace.methods.includes(e.request.method)?(d(this.client,e),await this.client.request(e)):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){const s=f(e);if(!this.httpProviders[s]){const n=t||a(`${this.name}:${s}`,this.namespace,this.client.core.projectId);if(!n)throw new Error(`No RPC url provided for chainId: ${s}`);this.setHttpProvider(s,n)}this.chainId=s,this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${s}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const s=t||a(`${this.name}:${e}`,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new h.JsonRpcProvider(new w.HttpConnection(s))}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const s=f(t);e[s]=this.createHttpProvider(s)}),e}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}getHttpProvider(){const e=this.chainId,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}handleSwitchChain(e){const t=parseInt(e,16),s=`${this.name}:${t}`;j(s,this.namespace.chains),this.setDefaultChain(`${t}`)}}class T{constructor(e){this.name="solana",this.namespace=e.namespace,this.events=e.events,this.client=e.client,this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?(d(this.client,e),this.client.request(e)):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const s=t||a(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.chainId=e,this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||a(e,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new h.JsonRpcProvider(new m.default(s))}}class F{constructor(e){this.name="cosmos",this.namespace=e.namespace,this.events=e.events,this.client=e.client,this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?(d(this.client,e),this.client.request(e)):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||a(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||a(e,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new h.JsonRpcProvider(new m.default(s))}}class G{constructor(e){this.name="cip34",this.namespace=e.namespace,this.events=e.events,this.client=e.client,this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?(d(this.client,e),this.client.request(e)):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||this.getCardanoRPCUrl(e);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const s=this.getCardanoRPCUrl(t);e[t]=this.createHttpProvider(t,s)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||this.getCardanoRPCUrl(e);return typeof s>"u"?void 0:new h.JsonRpcProvider(new m.default(s))}}var J=Object.defineProperty,z=Object.defineProperties,M=Object.getOwnPropertyDescriptors,E=Object.getOwnPropertySymbols,x=Object.prototype.hasOwnProperty,V=Object.prototype.propertyIsEnumerable,A=(i,e,t)=>e in i?J(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,l=(i,e)=>{for(var t in e||(e={}))x.call(e,t)&&A(i,t,e[t]);if(E)for(var t of E(e))V.call(e,t)&&A(i,t,e[t]);return i},g=(i,e)=>z(i,M(e));class u{constructor(e){this.events=new q.default,this.rpcProviders={},this.shouldAbortPairingAttempt=!1,this.maxPairingAttempts=10,this.providerOpts=e,this.logger=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:H.default(N.getDefaultLoggerOptions({level:e?.logger||C}))}static async init(e){const t=new u(e);return await t.initialize(),t}async request(e,t){const[s,n]=this.validateChain(t);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(s).request({request:l({},e),chainId:`${s}:${n}`,topic:this.session.topic})}sendAsync(e,t,s){this.request(e,s).then(n=>t(null,n)).catch(n=>t(n,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:v.getSdkError("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),await this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){this.shouldAbortPairingAttempt=!1;let t=0;do{if(this.shouldAbortPairingAttempt)throw new Error("Pairing aborted");if(t>=this.maxPairingAttempts)throw new Error("Max auto pairing attempts reached");const{uri:s,approval:n}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties});s&&(this.uri=s,this.events.emit("display_uri",s)),await n().then(r=>{this.session=r}).catch(r=>{if(r.message!==P.PROPOSAL_EXPIRY_MESSAGE)throw r;t++})}while(!this.session);return this.onConnect(),this.session}setDefaultChain(e,t){try{const[s,n]=this.validateChain(e);this.getProvider(s).setDefaultChain(n,t)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(e={}){this.logger.info("Cleaning up inactive pairings...");const t=this.client.pairing.getAll();if(v.isValidArray(t)){for(const s of t)e.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${t.length}`)}}abortPairingAttempt(){this.shouldAbortPairingAttempt=!0}async checkStorage(){if(this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.client.session.length){const e=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[e]),this.createProviders()}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await O.default.init({logger:this.providerOpts.logger||C,relayUrl:this.providerOpts.relayUrl||b,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,name:this.providerOpts.name}),this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");Object.keys(this.namespaces).forEach(e=>{var t,s,n;const r=((t=this.session)==null?void 0:t.namespaces[e].accounts)||[],$=L(r),c=g(l({},Object.assign(this.namespaces[e],(n=(s=this.optionalNamespaces)==null?void 0:s[e])!=null?n:{})),{accounts:r,chains:$});switch(e){case"eip155":this.rpcProviders[e]=new k({client:this.client,namespace:c,events:this.events});break;case"solana":this.rpcProviders[e]=new T({client:this.client,namespace:c,events:this.events});break;case"cosmos":this.rpcProviders[e]=new F({client:this.client,namespace:c,events:this.events});break;case"polkadot":break;case"cip34":this.rpcProviders[e]=new G({client:this.client,namespace:c,events:this.events});break}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{const{params:t}=e,{event:s}=t;s.name==="accountsChanged"?this.events.emit("accountsChanged",s.data):s.name==="chainChanged"?this.onChainChanged(t.chainId):this.events.emit(s.name,s.data),this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:t})=>{var s;const{namespaces:n}=t,r=(s=this.client)==null?void 0:s.session.get(e);this.session=g(l({},r),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:t})}),this.client.on("session_delete",async e=>{await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",g(l({},v.getSdkError("USER_DISCONNECTED")),{data:e.topic}))}),this.on(o.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(e,!0)})}getProvider(e){if(!this.rpcProviders[e])throw new Error(`Provider not found: ${e}`);return this.rpcProviders[e]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var t;this.getProvider(e).updateNamespace((t=this.session)==null?void 0:t.namespaces[e])})}setNamespaces(e){const{namespaces:t,optionalNamespaces:s,sessionProperties:n}=e;if(!t||!Object.keys(t).length)throw new Error("Namespaces must be not empty");this.namespaces=t,this.optionalNamespaces=s,this.sessionProperties=n,this.persist("namespaces",t),this.persist("optionalNamespaces",s)}validateChain(e){const[t,s]=e?.split(":")||["",""];if(t&&!Object.keys(this.namespaces).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);if(t&&s)return[t,s];const n=Object.keys(this.namespaces)[0],r=this.rpcProviders[n].getDefaultChain();return[n,r]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}onChainChanged(e,t=!1){const[s,n]=this.validateChain(e);t||this.getProvider(s).setDefaultChain(n),this.namespaces[s].defaultChain=n,this.persist("namespaces",this.namespaces),this.events.emit("chainChanged",n)}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0})}persist(e,t){this.client.core.storage.setItem(`${I}/${e}`,t)}async getFromStore(e){return await this.client.core.storage.getItem(`${I}/${e}`)}}const W=u;exports.UniversalProvider=W,exports.default=u;
//# sourceMappingURL=index.cjs.js.map
