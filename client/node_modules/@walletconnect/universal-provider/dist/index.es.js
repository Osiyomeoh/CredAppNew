import E from"pino";import A,{PROPOSAL_EXPIRY_MESSAGE as $}from"@walletconnect/sign-client";import{getSdkError as f,isValidArray as y}from"@walletconnect/utils";import{getDefaultLoggerOptions as N}from"@walletconnect/logger";import{JsonRpcProvider as h}from"@walletconnect/jsonrpc-provider";import u,{HttpConnection as H}from"@walletconnect/jsonrpc-http-connection";import O from"events";const g="error",b="wss://relay.walletconnect.com",q="wc",_="universal_provider",P=`${q}@${2}:${_}:`,D="https://rpc.walletconnect.com/v1",o={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function a(i,t,e){let s;const n=m(i);return t.rpcMap&&(s=t.rpcMap[n]),s||(s=`${D}?chainId=eip155:${n}&projectId=${e}`),s}function m(i){return i.includes("eip155")?Number(i.split(":")[1]):Number(i)}function S(i,t){if(!t.includes(i))throw new Error(`Chain '${i}' not approved. Please use one of the following: ${t.toString()}`)}function R(i){return i.map(t=>`${t.split(":")[0]}:${t.split(":")[1]}`)}const p=(i,t)=>{const e=s=>{s.request!==t.request||s.topic!==t.topic||(i.events.removeListener("session_request_sent",e),j())};i.on("session_request_sent",e)};function j(){if(typeof window<"u")try{const i=window.localStorage.getItem("WALLETCONNECT_DEEPLINK_CHOICE");if(i){const t=JSON.parse(i);window.open(t.href,"_self","noreferrer noopener")}}catch(i){console.error(i)}}class L{constructor(t){this.name="eip155",this.namespace=t.namespace,this.client=t.client,this.events=t.events,this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(t){var e;switch(t.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return this.handleSwitchChain(t.request.params?(e=t.request.params[0])==null?void 0:e.chainId:"0x0"),null;case"eth_chainId":return parseInt(this.getDefaultChain())}return this.namespace.methods.includes(t.request.method)?(p(this.client,t),await this.client.request(t)):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){const s=m(t);if(!this.httpProviders[s]){const n=e||a(`${this.name}:${s}`,this.namespace,this.client.core.projectId);if(!n)throw new Error(`No RPC url provided for chainId: ${s}`);this.setHttpProvider(s,n)}this.chainId=s,this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${s}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}createHttpProvider(t,e){const s=e||a(`${this.name}:${t}`,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new h(new H(s))}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{const s=m(e);t[s]=this.createHttpProvider(s)}),t}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}getHttpProvider(){const t=this.chainId,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}handleSwitchChain(t){const e=parseInt(t,16),s=`${this.name}:${e}`;S(s,this.namespace.chains),this.setDefaultChain(`${e}`)}}class U{constructor(t){this.name="solana",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?(p(this.client,t),this.client.request(t)):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(!this.httpProviders[t]){const s=e||a(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.chainId=t,this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||a(t,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new h(new u(s))}}class k{constructor(t){this.name="cosmos",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?(p(this.client,t),this.client.request(t)):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||a(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||a(t,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new h(new u(s))}}class T{constructor(t){this.name="cip34",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?(p(this.client,t),this.client.request(t)):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||this.getCardanoRPCUrl(t);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(o.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{const s=this.getCardanoRPCUrl(e);t[e]=this.createHttpProvider(e,s)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}getCardanoRPCUrl(t){const e=this.namespace.rpcMap;if(e)return e[t]}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||this.getCardanoRPCUrl(t);return typeof s>"u"?void 0:new h(new u(s))}}var F=Object.defineProperty,G=Object.defineProperties,z=Object.getOwnPropertyDescriptors,w=Object.getOwnPropertySymbols,x=Object.prototype.hasOwnProperty,J=Object.prototype.propertyIsEnumerable,C=(i,t,e)=>t in i?F(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,d=(i,t)=>{for(var e in t||(t={}))x.call(t,e)&&C(i,e,t[e]);if(w)for(var e of w(t))J.call(t,e)&&C(i,e,t[e]);return i},v=(i,t)=>G(i,z(t));class l{constructor(t){this.events=new O,this.rpcProviders={},this.shouldAbortPairingAttempt=!1,this.maxPairingAttempts=10,this.providerOpts=t,this.logger=typeof t?.logger<"u"&&typeof t?.logger!="string"?t.logger:E(N({level:t?.logger||g}))}static async init(t){const e=new l(t);return await e.initialize(),e}async request(t,e){const[s,n]=this.validateChain(e);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(s).request({request:d({},t),chainId:`${s}:${n}`,topic:this.session.topic})}sendAsync(t,e,s){this.request(t,s).then(n=>e(null,n)).catch(n=>e(n,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:f("USER_DISCONNECTED")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(t),await this.cleanupPendingPairings(),!t.skipPairing)return await this.pair(t.pairingTopic)}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){this.shouldAbortPairingAttempt=!1;let e=0;do{if(this.shouldAbortPairingAttempt)throw new Error("Pairing aborted");if(e>=this.maxPairingAttempts)throw new Error("Max auto pairing attempts reached");const{uri:s,approval:n}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties});s&&(this.uri=s,this.events.emit("display_uri",s)),await n().then(r=>{this.session=r}).catch(r=>{if(r.message!==$)throw r;e++})}while(!this.session);return this.onConnect(),this.session}setDefaultChain(t,e){try{const[s,n]=this.validateChain(t);this.getProvider(s).setDefaultChain(n,e)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(t={}){this.logger.info("Cleaning up inactive pairings...");const e=this.client.pairing.getAll();if(y(e)){for(const s of e)t.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${e.length}`)}}abortPairingAttempt(){this.shouldAbortPairingAttempt=!0}async checkStorage(){if(this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.client.session.length){const t=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[t]),this.createProviders()}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await A.init({logger:this.providerOpts.logger||g,relayUrl:this.providerOpts.relayUrl||b,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,name:this.providerOpts.name}),this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");Object.keys(this.namespaces).forEach(t=>{var e,s,n;const r=((e=this.session)==null?void 0:e.namespaces[t].accounts)||[],I=R(r),c=v(d({},Object.assign(this.namespaces[t],(n=(s=this.optionalNamespaces)==null?void 0:s[t])!=null?n:{})),{accounts:r,chains:I});switch(t){case"eip155":this.rpcProviders[t]=new L({client:this.client,namespace:c,events:this.events});break;case"solana":this.rpcProviders[t]=new U({client:this.client,namespace:c,events:this.events});break;case"cosmos":this.rpcProviders[t]=new k({client:this.client,namespace:c,events:this.events});break;case"polkadot":break;case"cip34":this.rpcProviders[t]=new T({client:this.client,namespace:c,events:this.events});break}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",t=>{this.events.emit("session_ping",t)}),this.client.on("session_event",t=>{const{params:e}=t,{event:s}=e;s.name==="accountsChanged"?this.events.emit("accountsChanged",s.data):s.name==="chainChanged"?this.onChainChanged(e.chainId):this.events.emit(s.name,s.data),this.events.emit("session_event",t)}),this.client.on("session_update",({topic:t,params:e})=>{var s;const{namespaces:n}=e,r=(s=this.client)==null?void 0:s.session.get(t);this.session=v(d({},r),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:e})}),this.client.on("session_delete",async t=>{await this.cleanup(),this.events.emit("session_delete",t),this.events.emit("disconnect",v(d({},f("USER_DISCONNECTED")),{data:t.topic}))}),this.on(o.DEFAULT_CHAIN_CHANGED,t=>{this.onChainChanged(t,!0)})}getProvider(t){if(!this.rpcProviders[t])throw new Error(`Provider not found: ${t}`);return this.rpcProviders[t]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var e;this.getProvider(t).updateNamespace((e=this.session)==null?void 0:e.namespaces[t])})}setNamespaces(t){const{namespaces:e,optionalNamespaces:s,sessionProperties:n}=t;if(!e||!Object.keys(e).length)throw new Error("Namespaces must be not empty");this.namespaces=e,this.optionalNamespaces=s,this.sessionProperties=n,this.persist("namespaces",e),this.persist("optionalNamespaces",s)}validateChain(t){const[e,s]=t?.split(":")||["",""];if(e&&!Object.keys(this.namespaces).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);if(e&&s)return[e,s];const n=Object.keys(this.namespaces)[0],r=this.rpcProviders[n].getDefaultChain();return[n,r]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}onChainChanged(t,e=!1){const[s,n]=this.validateChain(t);e||this.getProvider(s).setDefaultChain(n),this.namespaces[s].defaultChain=n,this.persist("namespaces",this.namespaces),this.events.emit("chainChanged",n)}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0})}persist(t,e){this.client.core.storage.setItem(`${P}/${t}`,e)}async getFromStore(t){return await this.client.core.storage.getItem(`${P}/${t}`)}}const M=l;export{M as UniversalProvider,l as default};
//# sourceMappingURL=index.es.js.map
